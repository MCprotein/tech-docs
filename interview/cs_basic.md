# Node.js 백엔드 개발자를 위한 CS 심화 지식

> Node.js 3~5년차 백엔드 개발자 면접을 위한 CS 심화 지식 정리.
> 각 주제별로 **순수 CS 개념**과 **Node.js 연계**를 모두 다룬다.

## 목차

1. [네트워크](#1-네트워크)
2. [자료구조와 알고리즘](#2-자료구조와-알고리즘)
3. [운영체제](#3-운영체제)
4. [데이터베이스](#4-데이터베이스)
5. [Node.js 런타임 심화](#5-nodejs-런타임-심화)

---

## 1. 네트워크

### 1.1 OSI 7계층 vs TCP/IP 4계층

```
OSI 7계층                    TCP/IP 4계층
┌─────────────────┐         ┌─────────────────┐
│  7. Application │         │                 │
├─────────────────┤         │  Application    │  HTTP, FTP, DNS, SMTP
│  6. Presentation│         │                 │
├─────────────────┤         │                 │
│  5. Session     │         ├─────────────────┤
├─────────────────┤         │  Transport      │  TCP, UDP
│  4. Transport   │         ├─────────────────┤
├─────────────────┤         │  Internet       │  IP, ICMP, ARP
│  3. Network     │         ├─────────────────┤
├─────────────────┤         │  Network        │
│  2. Data Link   │         │  Interface      │  Ethernet, Wi-Fi
├─────────────────┤         │                 │
│  1. Physical    │         └─────────────────┘
└─────────────────┘
```

**각 계층의 역할:**

| 계층              | 프로토콜  | PDU     | 핵심 역할                          |
| ----------------- | --------- | ------- | ---------------------------------- |
| Application       | HTTP, DNS | Message | 사용자 데이터                      |
| Transport         | TCP, UDP  | Segment | 포트 기반 프로세스 간 통신, 신뢰성 |
| Internet          | IP        | Packet  | IP 주소 기반 라우팅                |
| Network Interface | Ethernet  | Frame   | MAC 주소 기반 물리적 전송          |

### 1.2 TCP vs UDP

```
┌─────────────────────────────────────────────────────────────────┐
│  TCP (Transmission Control Protocol)                            │
│                                                                 │
│  특징:                                                          │
│  - 연결 지향 (3-way handshake)                                  │
│  - 순서 보장 (Sequence Number)                                  │
│  - 신뢰성 보장 (ACK, 재전송)                                    │
│  - 흐름 제어 (Window)                                           │
│  - 혼잡 제어 (Slow Start, Congestion Avoidance)                │
│                                                                 │
│  사용 사례: HTTP, HTTPS, SSH, FTP, SMTP                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  UDP (User Datagram Protocol)                                   │
│                                                                 │
│  특징:                                                          │
│  - 비연결 (Connectionless)                                      │
│  - 순서 보장 없음                                               │
│  - 신뢰성 없음 (Best Effort)                                    │
│  - 빠름, 오버헤드 적음                                          │
│                                                                 │
│  사용 사례: DNS, DHCP, 실시간 스트리밍, 게임, VoIP             │
└─────────────────────────────────────────────────────────────────┘
```

**TCP 헤더 구조:**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│          Source Port          │       Destination Port        │
├───────────────────────────────┴───────────────────────────────┤
│                        Sequence Number                        │
├───────────────────────────────────────────────────────────────┤
│                    Acknowledgment Number                      │
├───────┬───────┬─┬─┬─┬─┬─┬─┬───────────────────────────────────┤
│  Data │       │U│A│P│R│S│F│                                   │
│ Offset│ Rsrvd │R│C│S│S│Y│I│            Window                 │
│       │       │G│K│H│T│N│N│                                   │
├───────┴───────┴─┴─┴─┴─┴─┴─┴───────────────────────────────────┤
│           Checksum            │         Urgent Pointer        │
├───────────────────────────────┴───────────────────────────────┤
│                    Options (if any)                           │
├───────────────────────────────────────────────────────────────┤
│                             Data                              │
└───────────────────────────────────────────────────────────────┘

주요 플래그:
- SYN: 연결 요청
- ACK: 확인 응답
- FIN: 연결 종료
- RST: 연결 리셋
- PSH: 버퍼링 없이 즉시 전달
```

### 1.3 TCP 3-Way Handshake & 4-Way Handshake

**연결 수립 (3-Way Handshake):**

```
Client                                 Server
   │                                      │
   │──── SYN (Seq=x) ────────────────────▶│  1. 연결 요청
   │     "연결하고 싶어, 내 시작 번호는 x"   │
   │                                      │
   │◀─── SYN+ACK (Seq=y, Ack=x+1) ────────│  2. 요청 수락 + 연결 요청
   │     "OK, 내 시작 번호는 y,            │
   │      다음엔 x+1 보내줘"               │
   │                                      │
   │──── ACK (Seq=x+1, Ack=y+1) ──────────▶│  3. 연결 확인
   │     "OK, 다음엔 y+1 보내줘"           │
   │                                      │
   │══════════ ESTABLISHED ═══════════════│
```

**왜 3번인가?**

- 2번이면: 서버가 보낸 SYN+ACK가 클라이언트에게 도착했는지 서버가 모름
- 3번으로: 양방향 통신 가능 여부 확인 + 양쪽 시퀀스 번호 동기화

**연결 종료 (4-Way Handshake):**

```
Client                                 Server
   │                                      │
   │──── FIN (Seq=u) ────────────────────▶│  1. 종료 요청
   │     "나는 보낼 거 다 보냈어"          │
   │                                      │
   │◀─── ACK (Ack=u+1) ──────────────────│  2. 확인
   │     "OK, 알았어"                     │
   │                                      │  (서버가 남은 데이터 전송)
   │◀─── FIN (Seq=v) ────────────────────│  3. 서버도 종료
   │     "나도 다 보냈어"                  │
   │                                      │
   │──── ACK (Ack=v+1) ──────────────────▶│  4. 확인
   │     "OK"                             │
   │                                      │
   │═══ TIME_WAIT (2MSL) ════════════════│  지연 패킷 대비
   │                                      │
   │══════════ CLOSED ════════════════════│
```

**TIME_WAIT가 필요한 이유:**

1. 지연된 패킷이 새 연결에 영향 주는 것 방지
2. 마지막 ACK 손실 시 재전송 처리

### 1.4 TCP 흐름 제어 (Flow Control)

수신자가 처리할 수 있는 속도로 데이터 전송을 조절.

```
┌─────────────────────────────────────────────────────────────────┐
│  Sliding Window Protocol                                        │
│                                                                 │
│  송신자 버퍼:                                                    │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                     │
│  │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │                     │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                     │
│    ↑       ↑           ↑                                        │
│   ACK    전송중      Window                                      │
│   완료              경계                                         │
│                                                                 │
│  수신자 → 송신자: Window Size = 4                               │
│  "나는 4개까지 받을 수 있어"                                     │
│                                                                 │
│  버퍼 가득 참 → Window Size = 0 → 송신 중지                     │
│  버퍼 비워짐 → Window Update → 송신 재개                        │
└─────────────────────────────────────────────────────────────────┘
```

### 1.5 TCP 혼잡 제어 (Congestion Control)

네트워크 혼잡을 감지하고 전송 속도를 조절.

```
┌─────────────────────────────────────────────────────────────────┐
│  Congestion Window (cwnd) 변화                                  │
│                                                                 │
│  cwnd │                              ssthresh                   │
│       │                                 │                       │
│    32 │                            ┌────┴────  Congestion       │
│       │                       ┌────┘          Avoidance         │
│    16 │                  ┌────┘               (선형 증가)        │
│       │             ┌────┘                                      │
│     8 │        ┌────┘                                           │
│       │   ┌────┘   ← Slow Start (지수 증가)                     │
│     4 │───┘                                                     │
│     2 │─┘                                                       │
│     1 │                                                         │
│       └──────────────────────────────────────────── RTT         │
│                                                                 │
│  1. Slow Start: cwnd 지수적 증가 (1→2→4→8→16)                  │
│  2. ssthresh 도달: Congestion Avoidance로 전환                  │
│  3. Congestion Avoidance: cwnd 선형 증가 (16→17→18→...)        │
│  4. 패킷 손실 감지: ssthresh = cwnd/2, cwnd 재설정             │
└─────────────────────────────────────────────────────────────────┘
```

**패킷 손실 감지 방법:**

```
1. Timeout (RTO 만료)
   - cwnd = 1 (Slow Start부터 다시)
   - ssthresh = cwnd / 2

2. 3 Duplicate ACKs (Fast Retransmit)
   - cwnd = cwnd / 2 (급격한 감소 방지)
   - Fast Recovery 진입
```

### 1.6 HTTP/1.1 vs HTTP/2 vs HTTP/3

```
┌─────────────────────────────────────────────────────────────────┐
│  HTTP/1.1                                                       │
│                                                                 │
│  Connection 1: ──[Req1]──[Res1]──[Req2]──[Res2]──              │
│  Connection 2: ──[Req3]──[Res3]──[Req4]──[Res4]──              │
│                                                                 │
│  문제점:                                                         │
│  - Head-of-Line Blocking (앞 요청 완료까지 대기)               │
│  - 연결당 하나의 요청만 처리                                    │
│  - 헤더 중복 전송                                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  HTTP/2                                                         │
│                                                                 │
│  Single TCP Connection:                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Stream 1: ──[Headers]──[Data]──[Data]──                 │   │
│  │ Stream 2: ──[Headers]──[Data]──                         │   │
│  │ Stream 3: ──[Headers]──[Data]──[Data]──[Data]──         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  개선점:                                                         │
│  - Multiplexing (하나의 연결에서 여러 스트림)                   │
│  - Header Compression (HPACK)                                  │
│  - Server Push                                                  │
│  - Stream Prioritization                                        │
│                                                                 │
│  한계:                                                           │
│  - TCP Head-of-Line Blocking (패킷 손실 시 모든 스트림 대기)   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  HTTP/3 (QUIC)                                                  │
│                                                                 │
│  UDP 기반:                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Stream 1: ──[Data]──[Data]── (독립적)                   │   │
│  │ Stream 2: ──[Data]── (독립적)                           │   │
│  │ Stream 3: ──[Data]──[Data]──[Data]── (독립적)           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  개선점:                                                         │
│  - 스트림별 독립적 흐름 제어 (HOL Blocking 해결)               │
│  - 0-RTT 연결 재수립                                           │
│  - 연결 마이그레이션 (IP 변경되어도 연결 유지)                  │
│  - 내장 암호화 (TLS 1.3)                                       │
└─────────────────────────────────────────────────────────────────┘
```

### 1.7 HTTPS와 TLS/SSL 심화

#### 1.7.1 SSL vs TLS 역사

```
┌─────────────────────────────────────────────────────────────────┐
│  SSL/TLS 버전 역사                                               │
│                                                                 │
│  SSL 1.0 (1994) - 공개되지 않음, 보안 결함                       │
│  SSL 2.0 (1995) - 최초 공개, 심각한 취약점 (DROWN 등)            │
│  SSL 3.0 (1996) - 완전 재설계, POODLE 취약점 발견               │
│  ─────────────────────────────────────────────────────────────  │
│  TLS 1.0 (1999) - SSL 3.0 기반, 소폭 개선                        │
│  TLS 1.1 (2006) - CBC 공격 대응, IV 명시적 전송                  │
│  TLS 1.2 (2008) - SHA-256, AEAD 암호화 지원, 현재 가장 많이 사용 │
│  TLS 1.3 (2018) - Handshake 간소화, 레거시 암호 제거, 0-RTT     │
│                                                                 │
│  ⚠️  SSL 2.0/3.0, TLS 1.0/1.1 은 deprecated (보안 취약)         │
│  ✅ TLS 1.2 이상 권장, TLS 1.3이 최신                            │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.2 암호화 기초 개념

```
┌─────────────────────────────────────────────────────────────────┐
│  대칭키 암호화 (Symmetric Encryption)                           │
│                                                                 │
│  - 암호화/복호화에 동일한 키 사용                                │
│  - 빠름 (AES: ~1GB/s)                                           │
│  - 키 분배 문제: 어떻게 안전하게 키를 전달하나?                  │
│                                                                 │
│  Plain Text ──┬── [AES-256] + Key ──▶ Cipher Text              │
│               └── [AES-256] + Key ◀── Cipher Text (복호화)     │
│                                                                 │
│  알고리즘: AES-128/256, ChaCha20                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  비대칭키 암호화 (Asymmetric Encryption)                        │
│                                                                 │
│  - 공개키(Public Key)와 개인키(Private Key) 쌍 사용             │
│  - 공개키로 암호화 → 개인키로만 복호화 가능                      │
│  - 개인키로 서명 → 공개키로 검증 가능                            │
│  - 느림 (RSA: ~수 KB/s), 키 분배 문제 해결                       │
│                                                                 │
│  암호화: Plain ──[RSA + 공개키]──▶ Cipher                       │
│  복호화: Cipher ──[RSA + 개인키]──▶ Plain                       │
│                                                                 │
│  서명:   Hash(Data) ──[RSA + 개인키]──▶ Signature              │
│  검증:   Signature ──[RSA + 공개키]──▶ Hash → Data와 비교      │
│                                                                 │
│  알고리즘: RSA, ECDSA, Ed25519                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  하이브리드 암호화 (TLS가 사용하는 방식)                         │
│                                                                 │
│  문제: 비대칭키는 느리고, 대칭키는 키 분배가 어렵다              │
│  해결: 비대칭키로 대칭키를 안전하게 교환 → 대칭키로 통신         │
│                                                                 │
│  1. 비대칭키로 세션 키(대칭키) 교환 (느리지만 한 번만)           │
│  2. 교환된 대칭키로 실제 데이터 암호화 (빠름)                    │
│                                                                 │
│  ┌──────────────┐                    ┌──────────────┐           │
│  │   Client     │ ── 공개키 요청 ──▶ │   Server     │           │
│  │              │ ◀─ 공개키 전송 ─── │              │           │
│  │              │                    │              │           │
│  │ 세션키 생성  │                    │              │           │
│  │              │ ── [세션키]공개키 ─▶│ 개인키로    │           │
│  │              │    암호화 전송     │ 세션키 복호화│           │
│  │              │                    │              │           │
│  │   ═══════════ 세션키로 대칭 암호화 통신 ═══════════          │
│  └──────────────┘                    └──────────────┘           │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.3 Diffie-Hellman 키 교환 (DH / ECDHE)

```
┌─────────────────────────────────────────────────────────────────┐
│  Diffie-Hellman Key Exchange                                    │
│                                                                 │
│  목적: 도청자가 있는 채널에서 안전하게 공유 비밀 생성            │
│                                                                 │
│  수학적 원리:                                                    │
│  - 공개 파라미터: 큰 소수 p, 생성자 g                           │
│  - Alice: 비밀키 a 선택, 공개키 A = g^a mod p 계산              │
│  - Bob:   비밀키 b 선택, 공개키 B = g^b mod p 계산              │
│  - 공개키 교환 후:                                               │
│    - Alice: S = B^a mod p = g^(ab) mod p                        │
│    - Bob:   S = A^b mod p = g^(ab) mod p                        │
│  - 둘 다 같은 공유 비밀 S를 얻음!                                │
│                                                                 │
│  Alice                                Bob                       │
│    │                                   │                        │
│    │ 비밀키 a=6                        │ 비밀키 b=15            │
│    │ A = 5^6 mod 23 = 8                │ B = 5^15 mod 23 = 19   │
│    │                                   │                        │
│    │─────────── A=8 ──────────────────▶│                        │
│    │◀────────── B=19 ─────────────────│                        │
│    │                                   │                        │
│    │ S = 19^6 mod 23 = 2               │ S = 8^15 mod 23 = 2    │
│    │                                   │                        │
│    │      공유 비밀 S = 2 (동일!)       │                        │
│                                                                 │
│  도청자가 알 수 있는 것: p, g, A, B                              │
│  도청자가 알 수 없는 것: a, b, S (이산 로그 문제)                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)                │
│                                                                 │
│  - 타원곡선 암호 사용 (더 짧은 키로 동일한 보안 강도)            │
│  - RSA 2048bit ≈ ECDHE 224bit 보안 강도                         │
│  - Ephemeral: 매 세션마다 새 키쌍 생성                          │
│                                                                 │
│  장점:                                                           │
│  - Perfect Forward Secrecy (PFS): 개인키 유출되어도 과거 통신   │
│    해독 불가 (매 세션 키가 다르므로)                             │
│  - 더 빠르고 키가 짧음                                           │
│                                                                 │
│  TLS 1.3은 ECDHE 필수 (RSA 키 교환 제거됨)                       │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.4 인증서 (Certificate)와 PKI

```
┌─────────────────────────────────────────────────────────────────┐
│  X.509 인증서 구조                                               │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Certificate (인증서)                                    │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Version: 3                                              │    │
│  │  Serial Number: 고유 일련번호                            │    │
│  │  Signature Algorithm: sha256WithRSAEncryption           │    │
│  │                                                          │    │
│  │  Issuer (발급자):                                        │    │
│  │    CN=Let's Encrypt Authority X3                        │    │
│  │    O=Let's Encrypt                                       │    │
│  │                                                          │    │
│  │  Validity (유효기간):                                    │    │
│  │    Not Before: Jan 1 00:00:00 2024 GMT                  │    │
│  │    Not After:  Apr 1 00:00:00 2024 GMT                  │    │
│  │                                                          │    │
│  │  Subject (주체 - 인증서 소유자):                         │    │
│  │    CN=www.example.com                                    │    │
│  │                                                          │    │
│  │  Subject Public Key Info:                                │    │
│  │    Algorithm: RSA                                        │    │
│  │    Public Key: (2048 bit) 30 82 01 0a 02 82 01 01...   │    │
│  │                                                          │    │
│  │  Extensions:                                             │    │
│  │    Subject Alternative Name (SAN):                       │    │
│  │      DNS: www.example.com                                │    │
│  │      DNS: example.com                                    │    │
│  │      DNS: *.example.com (와일드카드)                     │    │
│  │    Key Usage: Digital Signature, Key Encipherment       │    │
│  │    Extended Key Usage: TLS Web Server Authentication    │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Signature (발급자의 서명):                              │    │
│  │    CA가 위 내용을 해시 → CA 개인키로 서명               │    │
│  │    65 c9 4f 04 a2 ... (256 bytes)                       │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  PKI (Public Key Infrastructure) 인증서 체인                     │
│                                                                 │
│  ┌──────────────────┐                                           │
│  │   Root CA        │ ← 자체 서명 (Self-Signed)                 │
│  │   (신뢰의 닻)    │   OS/브라우저에 미리 설치됨                │
│  └────────┬─────────┘                                           │
│           │ 서명                                                 │
│           ▼                                                     │
│  ┌──────────────────┐                                           │
│  │  Intermediate CA │ ← Root CA가 서명                          │
│  │  (중간 인증기관) │   Root CA 보호 (오프라인 보관)            │
│  └────────┬─────────┘                                           │
│           │ 서명                                                 │
│           ▼                                                     │
│  ┌──────────────────┐                                           │
│  │  End Entity Cert │ ← Intermediate CA가 서명                  │
│  │  (서버 인증서)   │   www.example.com                         │
│  └──────────────────┘                                           │
│                                                                 │
│  검증 과정:                                                      │
│  1. 서버가 인증서 체인 전체 전송                                 │
│  2. End Entity 인증서 → Intermediate CA 공개키로 서명 검증      │
│  3. Intermediate CA → Root CA 공개키로 서명 검증                │
│  4. Root CA가 신뢰 저장소에 있는지 확인                         │
│  5. 도메인명, 유효기간, 폐기 여부 확인                           │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  인증서 검증 상세 과정                                           │
│                                                                 │
│  Client가 서버 인증서 받은 후:                                   │
│                                                                 │
│  1. 체인 구성 (Chain Building)                                  │
│     - 서버 인증서의 Issuer 필드 확인                             │
│     - 해당 발급자의 인증서 찾기 (서버가 제공 or AIA 확장자)      │
│     - Root CA까지 체인 완성                                      │
│                                                                 │
│  2. 서명 검증 (Signature Verification)                          │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 서버 인증서:                                         │     │
│     │   TBSCertificate (서명 대상 데이터)                 │     │
│     │   SignatureAlgorithm: sha256WithRSA                 │     │
│     │   Signature: 0x1234...                              │     │
│     │                                                      │     │
│     │ 검증:                                                │     │
│     │   H1 = SHA256(TBSCertificate)                       │     │
│     │   H2 = RSA_Verify(Signature, CA공개키)              │     │
│     │   H1 == H2 ? 유효 : 변조됨                          │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                 │
│  3. 유효성 검사                                                  │
│     - 유효기간: Not Before ≤ 현재 ≤ Not After                   │
│     - 도메인: SAN에 요청 도메인 포함?                            │
│     - 용도: Key Usage에 TLS 서버 인증 포함?                      │
│                                                                 │
│  4. 폐기 확인 (Revocation Check)                                │
│     - CRL (Certificate Revocation List): 폐기 목록 다운로드     │
│     - OCSP (Online Certificate Status Protocol): 실시간 조회    │
│     - OCSP Stapling: 서버가 OCSP 응답 미리 첨부                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.5 TLS 1.2 Handshake (상세)

```
┌─────────────────────────────────────────────────────────────────┐
│  TLS 1.2 Full Handshake (2-RTT)                                 │
│                                                                 │
│  Client                                Server                   │
│     │                                      │                    │
│     │──── ClientHello ────────────────────▶│   ┐               │
│     │     Protocol Version: TLS 1.2        │   │               │
│     │     Random: 32 bytes (타임스탬프 + 랜덤)│   │               │
│     │     Session ID: (재연결시 사용)       │   │               │
│     │     Cipher Suites:                   │   │               │
│     │       TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384              │
│     │       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256              │
│     │       ...                            │   │ RTT 1         │
│     │     Compression Methods: null        │   │               │
│     │     Extensions:                      │   │               │
│     │       server_name: example.com (SNI) │   │               │
│     │       supported_groups: x25519, P-256│   │               │
│     │       signature_algorithms: ...      │   │               │
│     │                                      │   │               │
│     │◀─── ServerHello ────────────────────│   │               │
│     │     Protocol Version: TLS 1.2        │   │               │
│     │     Random: 32 bytes                 │   │               │
│     │     Session ID                       │   │               │
│     │     Selected Cipher Suite            │   │               │
│     │                                      │   ┘               │
│     │◀─── Certificate ────────────────────│                    │
│     │     서버 인증서 체인                   │                    │
│     │                                      │                    │
│     │◀─── ServerKeyExchange ──────────────│                    │
│     │     ECDHE 공개키 + 서명              │                    │
│     │     (RSA 키교환시 생략)               │                    │
│     │                                      │                    │
│     │◀─── CertificateRequest (optional) ──│                    │
│     │     클라이언트 인증서 요청 (mTLS)     │                    │
│     │                                      │                    │
│     │◀─── ServerHelloDone ────────────────│                    │
│     │                                      │                    │
│     │──── ClientKeyExchange ──────────────▶│   ┐               │
│     │     ECDHE 공개키 or                  │   │               │
│     │     RSA 암호화된 Pre-Master Secret   │   │               │
│     │                                      │   │               │
│     │──── [Certificate] (mTLS시) ─────────▶│   │               │
│     │──── [CertificateVerify] (mTLS시) ───▶│   │               │
│     │                                      │   │ RTT 2         │
│     │──── ChangeCipherSpec ───────────────▶│   │               │
│     │     "이제부터 암호화 시작"             │   │               │
│     │                                      │   │               │
│     │──── Finished ───────────────────────▶│   │               │
│     │     verify_data = PRF(master_secret, │   │               │
│     │       "client finished", Hash(msgs)) │   │               │
│     │                                      │   │               │
│     │◀─── ChangeCipherSpec ───────────────│   │               │
│     │◀─── Finished ───────────────────────│   ┘               │
│     │                                      │                    │
│     │══════════ 암호화된 Application Data ══════════           │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  TLS 1.2 키 유도 과정                                            │
│                                                                 │
│  1. Pre-Master Secret 생성                                      │
│     - ECDHE: DH 공유 비밀                                       │
│     - RSA: 클라이언트가 생성한 48바이트 랜덤                     │
│                                                                 │
│  2. Master Secret 생성                                          │
│     master_secret = PRF(pre_master_secret,                      │
│                         "master secret",                        │
│                         client_random + server_random)          │
│                                                                 │
│  3. 세션 키 유도                                                 │
│     key_block = PRF(master_secret,                              │
│                     "key expansion",                            │
│                     server_random + client_random)              │
│                                                                 │
│     key_block에서 추출:                                          │
│     - client_write_MAC_key (HMAC용)                             │
│     - server_write_MAC_key                                      │
│     - client_write_key (암호화용)                               │
│     - server_write_key                                          │
│     - client_write_IV                                           │
│     - server_write_IV                                           │
│                                                                 │
│  PRF = Pseudo-Random Function (TLS 1.2: SHA-256 기반)          │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.6 TLS 1.3 Handshake (상세)

```
┌─────────────────────────────────────────────────────────────────┐
│  TLS 1.3 Full Handshake (1-RTT) - 대폭 간소화!                  │
│                                                                 │
│  Client                                Server                   │
│     │                                      │                    │
│     │──── ClientHello ────────────────────▶│                    │
│     │     supported_versions: TLS 1.3      │                    │
│     │     supported_groups: x25519, P-256  │                    │
│     │     signature_algorithms             │                    │
│     │     key_share: x25519 공개키         │  ← 미리 키 전송!   │
│     │                                      │                    │
│     │◀─── ServerHello ────────────────────│                    │
│     │     selected version: TLS 1.3        │                    │
│     │     key_share: x25519 공개키         │                    │
│     │                                      │                    │
│     │   [여기서부터 암호화 시작!]           │                    │
│     │                                      │                    │
│     │◀─── {EncryptedExtensions} ──────────│                    │
│     │◀─── {CertificateRequest} (optional) │                    │
│     │◀─── {Certificate} ──────────────────│                    │
│     │◀─── {CertificateVerify} ────────────│                    │
│     │     서명 = Sign(개인키, Transcript)  │                    │
│     │◀─── {Finished} ─────────────────────│                    │
│     │     verify_data = HMAC(finished_key, │                    │
│     │       Transcript-Hash)               │                    │
│     │                                      │                    │
│     │──── {Certificate} (mTLS시) ─────────▶│                    │
│     │──── {CertificateVerify} (mTLS시) ───▶│                    │
│     │──── {Finished} ─────────────────────▶│                    │
│     │                                      │                    │
│     │══════════ 암호화된 Application Data ══════════           │
│                                                                 │
│  { } = Handshake Secret으로 암호화된 메시지                      │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  TLS 1.3 vs 1.2 주요 차이점                                      │
│                                                                 │
│  ┌───────────────────┬──────────────────┬──────────────────┐    │
│  │                   │ TLS 1.2          │ TLS 1.3          │    │
│  ├───────────────────┼──────────────────┼──────────────────┤    │
│  │ Handshake RTT     │ 2-RTT            │ 1-RTT (0-RTT*)   │    │
│  │ 키 교환           │ RSA, DHE, ECDHE  │ ECDHE만 (PFS 필수) │   │
│  │ 암호화 시작       │ Finished 후      │ ServerHello 직후 │    │
│  │ 암호 스위트       │ 37개+            │ 5개 (엄선)       │    │
│  │ 메시지 암호화     │ Finished만       │ 대부분 암호화    │    │
│  │ Session Ticket    │ 평문             │ 암호화           │    │
│  │ 인증서 암호화     │ 평문             │ 암호화           │    │
│  └───────────────────┴──────────────────┴──────────────────┘    │
│                                                                 │
│  TLS 1.3에서 제거된 것:                                          │
│  - RSA 키 교환 (PFS 없음)                                        │
│  - CBC 모드 암호 (POODLE, Lucky 13 등 취약)                     │
│  - RC4, DES, 3DES, MD5, SHA-1                                   │
│  - 압축 (CRIME 공격)                                             │
│  - 재협상 (Renegotiation)                                        │
│  - ChangeCipherSpec 메시지                                       │
│                                                                 │
│  TLS 1.3 암호 스위트 (전부):                                     │
│  - TLS_AES_256_GCM_SHA384                                        │
│  - TLS_AES_128_GCM_SHA256                                        │
│  - TLS_CHACHA20_POLY1305_SHA256                                  │
│  - TLS_AES_128_CCM_SHA256                                        │
│  - TLS_AES_128_CCM_8_SHA256                                      │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.7 TLS 1.3 0-RTT (Early Data)

```
┌─────────────────────────────────────────────────────────────────┐
│  0-RTT Resumption                                               │
│                                                                 │
│  이전 연결에서 PSK(Pre-Shared Key)를 저장한 경우,               │
│  첫 메시지에 암호화된 데이터를 함께 전송 가능                     │
│                                                                 │
│  Client                                Server                   │
│     │                                      │                    │
│     │──── ClientHello ────────────────────▶│                    │
│     │     + pre_shared_key                 │                    │
│     │     + early_data                     │                    │
│     │──── {Application Data} ─────────────▶│  ← 0-RTT 데이터!  │
│     │     (PSK에서 유도된 키로 암호화)       │                    │
│     │                                      │                    │
│     │◀─── ServerHello ────────────────────│                    │
│     │◀─── {EncryptedExtensions} ──────────│                    │
│     │     + early_data (수락시)            │                    │
│     │◀─── {Finished} ─────────────────────│                    │
│     │                                      │                    │
│     │──── {EndOfEarlyData} ───────────────▶│                    │
│     │──── {Finished} ─────────────────────▶│                    │
│                                                                 │
│  ⚠️  0-RTT 보안 주의사항:                                       │
│  - Replay Attack 취약: 공격자가 0-RTT 데이터 재전송 가능        │
│  - 멱등성(Idempotent) 요청만 0-RTT로 보내야 함                  │
│  - GET은 OK, POST/PUT/DELETE는 위험                             │
│  - Forward Secrecy 약함 (PSK 유출시 0-RTT 해독 가능)            │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.8 mTLS (Mutual TLS / 양방향 인증)

```
┌─────────────────────────────────────────────────────────────────┐
│  일반 TLS vs mTLS                                                │
│                                                                 │
│  일반 TLS (단방향):                                              │
│  ┌──────────┐              ┌──────────┐                         │
│  │  Client  │───────────▶ │  Server  │                         │
│  │          │  "서버 누구?"│ 인증서   │                         │
│  │   신원   │◀───────────│ 제시     │                         │
│  │  확인 X  │              │          │                         │
│  └──────────┘              └──────────┘                         │
│  클라이언트는 서버만 인증, 서버는 클라이언트 신원 모름          │
│                                                                 │
│  mTLS (양방향):                                                  │
│  ┌──────────┐              ┌──────────┐                         │
│  │  Client  │───────────▶ │  Server  │                         │
│  │ 인증서   │  양방향     │ 인증서   │                         │
│  │ 제시     │◀───────────│ 제시     │                         │
│  │          │              │          │                         │
│  └──────────┘              └──────────┘                         │
│  서버도 클라이언트 인증서 검증 → 신뢰된 클라이언트만 접근       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  mTLS 사용 사례                                                  │
│                                                                 │
│  1. 마이크로서비스 간 통신 (Service Mesh)                       │
│     - Istio, Linkerd에서 서비스 간 mTLS 자동 적용               │
│     - 서비스 A ←mTLS→ 서비스 B (상호 인증)                      │
│                                                                 │
│  2. API 클라이언트 인증                                          │
│     - API 키 대신 인증서로 클라이언트 식별                       │
│     - 금융, 의료 등 높은 보안 요구 시스템                        │
│                                                                 │
│  3. IoT 디바이스 인증                                            │
│     - 각 디바이스에 고유 인증서 발급                             │
│     - 디바이스 위변조 방지                                       │
│                                                                 │
│  4. Zero Trust Architecture                                     │
│     - 네트워크 위치가 아닌 신원 기반 접근 제어                   │
│     - "신뢰하지 말고, 항상 검증하라"                             │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.9 Node.js TLS 구현

```typescript
// Node.js TLS 서버 (mTLS 포함)
import * as tls from 'tls';
import * as fs from 'fs';

const options: tls.TlsOptions = {
  // 서버 인증서
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),

  // mTLS: 클라이언트 인증서 요구
  requestCert: true,
  rejectUnauthorized: true, // 유효하지 않은 인증서 거부
  ca: [fs.readFileSync('client-ca-cert.pem')], // 신뢰할 CA

  // TLS 버전 제한
  minVersion: 'TLSv1.2',
  maxVersion: 'TLSv1.3',

  // 암호 스위트 (TLS 1.2용)
  ciphers: [
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-ECDSA-CHACHA20-POLY1305',
  ].join(':'),

  // TLS 1.3 암호 스위트
  cipherSuites: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
  ].join(':'),

  // ECDHE 곡선
  ecdhCurve: 'X25519:P-256:P-384',

  // Session Ticket (세션 재사용)
  sessionTimeout: 300,
};

const server = tls.createServer(options, (socket) => {
  console.log('연결됨:', socket.authorized ? '인증됨' : '인증 실패');

  // 클라이언트 인증서 정보
  const cert = socket.getPeerCertificate();
  if (cert.subject) {
    console.log('클라이언트 CN:', cert.subject.CN);
    console.log('발급자:', cert.issuer.CN);
  }

  // 협상된 프로토콜 정보
  console.log('TLS 버전:', socket.getProtocol());  // TLSv1.3
  console.log('암호 스위트:', socket.getCipher()); // { name, version }

  socket.write('Hello, authenticated client!\n');
  socket.pipe(socket); // echo
});

server.listen(8443);
```

```typescript
// HTTPS 서버 with Node.js (Express)
import * as https from 'https';
import * as fs from 'fs';
import express from 'express';

const app = express();

app.get('/', (req, res) => {
  // req.socket에서 TLS 정보 접근
  const tlsSocket = req.socket as tls.TLSSocket;

  res.json({
    protocol: tlsSocket.getProtocol(),
    cipher: tlsSocket.getCipher(),
    authorized: tlsSocket.authorized,
    // mTLS시 클라이언트 인증서
    clientCert: tlsSocket.getPeerCertificate()?.subject,
  });
});

const httpsServer = https.createServer({
  key: fs.readFileSync('key.pem'),
  cert: fs.readFileSync('cert.pem'),
  minVersion: 'TLSv1.2',
}, app);

httpsServer.listen(443);
```

```typescript
// TLS 클라이언트 (mTLS)
import * as tls from 'tls';
import * as fs from 'fs';

const options: tls.ConnectionOptions = {
  host: 'api.example.com',
  port: 443,

  // 클라이언트 인증서 (mTLS)
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // 서버 인증서 검증
  ca: [fs.readFileSync('server-ca-cert.pem')],
  checkServerIdentity: (hostname, cert) => {
    // 커스텀 서버 신원 검증
    // 기본: 인증서의 SAN/CN이 hostname과 일치하는지 확인
    return tls.checkServerIdentity(hostname, cert);
  },

  // SNI (Server Name Indication)
  servername: 'api.example.com',

  // ALPN (Application-Layer Protocol Negotiation)
  ALPNProtocols: ['h2', 'http/1.1'],

  // Session 재사용
  session: previousSession, // 이전 세션 티켓
};

const socket = tls.connect(options, () => {
  console.log('연결됨, 서버 인증:', socket.authorized);
  console.log('ALPN 프로토콜:', socket.alpnProtocol); // 'h2' or 'http/1.1'

  // 세션 저장 (0-RTT 재사용)
  const session = socket.getSession();

  socket.write('GET / HTTP/1.1\r\nHost: api.example.com\r\n\r\n');
});
```

#### 1.7.10 인증서 발급 및 관리

```
┌─────────────────────────────────────────────────────────────────┐
│  인증서 발급 방식                                                │
│                                                                 │
│  1. 상용 CA (DigiCert, GlobalSign 등)                           │
│     - 유료, 높은 신뢰도                                          │
│     - EV (Extended Validation) 인증서: 조직 실사                │
│     - 기업용, 금융권                                             │
│                                                                 │
│  2. Let's Encrypt (무료)                                         │
│     - ACME 프로토콜 자동화                                       │
│     - 90일 유효 (자동 갱신)                                      │
│     - DV (Domain Validation) 만 지원                            │
│     - certbot, acme.sh 등 도구 사용                              │
│                                                                 │
│  3. 사설 CA (Private PKI)                                        │
│     - 내부 시스템용 (마이크로서비스, mTLS)                       │
│     - Vault, step-ca, cfssl 등                                  │
│     - 클라이언트에 Root CA 수동 설치 필요                        │
│                                                                 │
│  4. Self-Signed (개발용)                                         │
│     - 빠른 생성, 신뢰되지 않음                                   │
│     - 개발/테스트 환경 only                                      │
└─────────────────────────────────────────────────────────────────┘

# OpenSSL로 인증서 생성 (Self-Signed)
# 1. 개인키 생성
openssl genrsa -out server.key 2048

# 2. CSR (Certificate Signing Request) 생성
openssl req -new -key server.key -out server.csr

# 3. 자체 서명 인증서 생성 (365일 유효)
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

# 4. 인증서 정보 확인
openssl x509 -in server.crt -text -noout

# 5. 서버 인증서 체인 확인 (온라인)
openssl s_client -connect example.com:443 -showcerts
```

```
┌─────────────────────────────────────────────────────────────────┐
│  ACME (Let's Encrypt) 인증 방식                                  │
│                                                                 │
│  HTTP-01 Challenge:                                              │
│  1. ACME 서버가 랜덤 토큰 제공                                   │
│  2. 클라이언트가 /.well-known/acme-challenge/{token} 에 응답 배치│
│  3. ACME 서버가 HTTP로 접근하여 도메인 소유권 확인               │
│  4. 인증서 발급                                                  │
│                                                                 │
│  DNS-01 Challenge:                                               │
│  1. ACME 서버가 랜덤 값 제공                                     │
│  2. _acme-challenge.example.com TXT 레코드에 값 설정            │
│  3. ACME 서버가 DNS 조회로 도메인 소유권 확인                    │
│  4. 와일드카드 인증서 발급 가능                                   │
│                                                                 │
│  TLS-ALPN-01 Challenge:                                          │
│  1. 443 포트에서 특수 ALPN 프로토콜로 응답                       │
│  2. HTTP 서버 없이도 가능                                        │
└─────────────────────────────────────────────────────────────────┘
```

#### 1.7.11 TLS 보안 공격과 대응

```
┌─────────────────────────────────────────────────────────────────┐
│  주요 TLS 공격 및 대응                                           │
│                                                                 │
│  1. MITM (Man-in-the-Middle)                                    │
│     공격: 통신 중간에서 가로채기                                 │
│     대응: 인증서 검증, Certificate Pinning                      │
│                                                                 │
│  2. Downgrade Attack                                             │
│     공격: 강제로 낮은 TLS 버전/약한 암호 사용 유도              │
│     대응: TLS_FALLBACK_SCSV, 최소 버전 강제                     │
│                                                                 │
│  3. BEAST (TLS 1.0)                                              │
│     공격: CBC 모드의 IV 예측 가능성 악용                         │
│     대응: TLS 1.1+ 사용, GCM 모드                               │
│                                                                 │
│  4. POODLE (SSL 3.0)                                             │
│     공격: SSL 3.0 CBC 패딩 취약점                                │
│     대응: SSL 3.0 비활성화                                       │
│                                                                 │
│  5. Heartbleed (OpenSSL 버그)                                    │
│     공격: 메모리 누출로 개인키 탈취                              │
│     대응: 패치, 인증서 재발급                                    │
│                                                                 │
│  6. CRIME/BREACH                                                 │
│     공격: TLS 압축을 이용한 평문 추측                            │
│     대응: TLS 압축 비활성화 (TLS 1.3은 기본 제거)               │
│                                                                 │
│  7. Replay Attack (0-RTT)                                        │
│     공격: 0-RTT 데이터 재전송                                    │
│     대응: 멱등성 요청만 0-RTT 사용, 서버측 replay 방지          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Certificate Pinning (인증서 고정)                               │
│                                                                 │
│  문제: CA가 해킹당하면 가짜 인증서 발급 가능                     │
│  해결: 특정 인증서/공개키만 신뢰하도록 고정                      │
│                                                                 │
│  방식:                                                           │
│  - HPKP (HTTP Public Key Pinning): deprecated                   │
│  - 앱 내 Pinning: 모바일 앱에서 많이 사용                        │
│  - Certificate Transparency (CT) 로그 모니터링                  │
│                                                                 │
│  Node.js 예시:                                                   │
│  const options = {                                               │
│    checkServerIdentity: (host, cert) => {                       │
│      const validFingerprints = [                                │
│        'SHA256:AAAA...',                                         │
│        'SHA256:BBBB...',                                         │
│      ];                                                          │
│      const certFingerprint = cert.fingerprint256;               │
│      if (!validFingerprints.includes(certFingerprint)) {        │
│        return new Error('Certificate pinning failed');          │
│      }                                                           │
│    }                                                             │
│  };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 1.7.12 면접 포인트 정리 (TLS/HTTPS)

| 질문                          | 핵심 답변                                                                          |
| ----------------------------- | ---------------------------------------------------------------------------------- |
| TLS와 SSL 차이?               | SSL은 deprecated된 이전 이름. TLS 1.0이 SSL 3.0 후속. 현재 TLS 1.2/1.3 사용        |
| 대칭키 vs 비대칭키?           | 대칭키: 같은 키로 암/복호화, 빠름. 비대칭키: 공개/개인키 쌍, 느리지만 키 분배 해결 |
| TLS가 하이브리드인 이유?      | 비대칭키로 대칭키(세션키) 교환 → 대칭키로 실제 데이터 암호화. 양쪽 장점 활용      |
| ECDHE란?                      | 타원곡선 디피헬만. 매 세션 새 키 생성(Ephemeral)으로 PFS 제공                      |
| PFS(Perfect Forward Secrecy)? | 개인키 유출되어도 과거 세션 해독 불가. ECDHE 사용시 보장                           |
| TLS 1.3 개선점?               | 1-RTT handshake, RSA 키교환 제거(PFS 필수), 레거시 암호 제거, 인증서 암호화        |
| 인증서 검증 과정?             | 서명 검증(CA 공개키) → 체인 검증 → 유효기간/도메인 확인 → 폐기 여부(OCSP/CRL)   |
| mTLS란?                       | 양방향 인증. 서버도 클라이언트 인증서 검증. 마이크로서비스, Zero Trust에 사용      |
| 0-RTT 위험성?                 | Replay Attack 가능. 멱등성 요청만 사용해야 함                                      |
| SNI란?                        | Server Name Indication. 하나의 IP에서 여러 도메인 인증서 제공 가능                 |

### 1.7.13 SSH 인증과 PEM 파일

#### SSH 키 기반 인증 동작 원리

```
┌─────────────────────────────────────────────────────────────────┐
│  SSH 키 쌍 생성 및 배포                                          │
│                                                                 │
│  1. 클라이언트에서 키 쌍 생성:                                   │
│     ssh-keygen -t rsa -b 4096 -f ~/.ssh/my_key                 │
│                                                                 │
│     결과:                                                        │
│     ~/.ssh/my_key      ← 개인키 (Private Key) - 절대 공유 금지  │
│     ~/.ssh/my_key.pub  ← 공개키 (Public Key) - 서버에 등록      │
│                                                                 │
│  2. 서버에 공개키 등록:                                          │
│     서버의 ~/.ssh/authorized_keys 에 공개키 추가                │
│                                                                 │
│  ┌──────────────┐                    ┌──────────────┐           │
│  │   Client     │                    │    Server    │           │
│  │              │                    │              │           │
│  │ 개인키 보관  │                    │ 공개키 저장  │           │
│  │ (my_key)     │                    │ (authorized_ │           │
│  │              │                    │  keys)       │           │
│  └──────────────┘                    └──────────────┘           │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  SSH 키 기반 인증 흐름                                           │
│                                                                 │
│  Client                                Server                   │
│     │                                      │                    │
│     │──── 1. 연결 요청 ───────────────────▶│                    │
│     │      "ssh user@server"               │                    │
│     │                                      │                    │
│     │◀─── 2. 서버 공개키 전송 ────────────│                    │
│     │      (서버 신원 확인용)              │                    │
│     │      "이 서버가 맞나요?"              │                    │
│     │                                      │                    │
│     │──── 3. 클라이언트 공개키 제시 ──────▶│                    │
│     │      "이 공개키로 인증할게요"         │                    │
│     │                                      │                    │
│     │      4. 서버: authorized_keys에서    │                    │
│     │         해당 공개키 찾음              │                    │
│     │                                      │                    │
│     │◀─── 5. Challenge 전송 ──────────────│                    │
│     │      랜덤 데이터를 공개키로 암호화    │                    │
│     │      "이거 복호화 해봐"               │                    │
│     │                                      │                    │
│     │      6. 클라이언트: 개인키로 복호화   │                    │
│     │         + 세션ID와 함께 서명          │                    │
│     │                                      │                    │
│     │──── 7. Response (서명) 전송 ────────▶│                    │
│     │                                      │                    │
│     │      8. 서버: 공개키로 서명 검증      │                    │
│     │         "개인키 소유자 맞음!"          │                    │
│     │                                      │                    │
│     │◀─── 9. 인증 성공 ───────────────────│                    │
│     │                                      │                    │
│     │═══════════ 암호화된 세션 시작 ═══════════                 │
│                                                                 │
│  핵심: 개인키는 절대 네트워크로 전송되지 않음!                   │
│        서버는 "개인키 소유 증명"만 확인                          │
└─────────────────────────────────────────────────────────────────┘
```

#### 비대칭키 암호화가 SSH 인증에서 동작하는 원리

```
┌─────────────────────────────────────────────────────────────────┐
│  왜 개인키로 "문제를 풀 수" 있는가?                              │
│                                                                 │
│  비대칭키(공개키/개인키)의 수학적 특성:                          │
│                                                                 │
│  ┌─────────────┐         ┌─────────────┐                        │
│  │   공개키     │◀──쌍──▶│   개인키     │                        │
│  │  (자물쇠)   │         │   (열쇠)    │                        │
│  │             │         │             │                        │
│  │ • 암호화    │         │ • 복호화    │                        │
│  │ • 서명 검증 │         │ • 서명      │                        │
│  └─────────────┘         └─────────────┘                        │
│                                                                 │
│  핵심: 공개키로 암호화한 것은 오직 짝이 되는 개인키로만 복호화   │
│        수학적으로 연결된 한 쌍이기 때문                          │
│                                                                 │
│  비유:                                                           │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ 서버: 네 공개키(자물쇠)로 상자를 잠갔어. 열어봐.          │   │
│  │                                                           │   │
│  │      ┌──────────┐                                         │   │
│  │      │ 랜덤값   │ 🔒 ← 공개키로 잠금                      │   │
│  │      └──────────┘                                         │   │
│  │                                                           │   │
│  │ 클라이언트: (개인키로 열고) 안에 "ABC123" 있었어!          │   │
│  │                                                           │   │
│  │ 서버: 맞아, 내가 넣은 값이랑 똑같네. 열쇠 가진 사람이네!  │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  SSH 인증 상세 흐름 (Challenge-Response)                         │
│                                                                 │
│  1. 서버: 랜덤값 "XYZ789" 생성                                   │
│           │                                                     │
│           ▼                                                     │
│  2. 서버: 클라이언트 공개키로 암호화                             │
│           encrypt("XYZ789", 클라이언트_공개키) → 암호문          │
│           │                                                     │
│           ▼                                                     │
│  3. 서버 → 클라이언트: 암호문 전송                               │
│           │                                                     │
│           ▼                                                     │
│  4. 클라이언트: 개인키로 복호화                                  │
│           decrypt(암호문, 개인키) → "XYZ789"                     │
│           │                                                     │
│           ▼                                                     │
│  5. 클라이언트 → 서버: "XYZ789" 응답 (+ 서명)                    │
│           │                                                     │
│           ▼                                                     │
│  6. 서버: 내가 보낸 "XYZ789"랑 같은지 비교                       │
│           같으면 → 인증 성공! (개인키 소유 증명됨)               │
│           다르면 → 인증 실패                                    │
│                                                                 │
│  결론: "이 암호문을 풀 수 있는 개인키를 가졌냐?"를 확인하는 것   │
└─────────────────────────────────────────────────────────────────┘
```

#### 서버의 공개키 관리 (authorized_keys)

```
┌─────────────────────────────────────────────────────────────────┐
│  Q: 사람마다 개인키가 다른데, 서버가 모든 공개키를 가지고 있나?  │
│                                                                 │
│  A: 맞다! 서버의 ~/.ssh/authorized_keys 파일에 전부 저장됨      │
│                                                                 │
│  # 서버의 ~/.ssh/authorized_keys 파일 내용                      │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ... user1@laptop   │   │
│  │ ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQ... user2@desktop  │   │
│  │ ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI... user3@macbook   │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
│  한 줄에 공개키 하나씩                                           │
│  여기 등록된 공개키의 개인키를 가진 사람만 접속 가능             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  서버 (authorized_keys)                                          │
│                                                                 │
│  철수 공개키: ssh-rsa AAAA...                                    │
│  영희 공개키: ssh-rsa BBBB...                                    │
│  민수 공개키: ssh-ed25519 CCCC...                                │
│                                                                 │
│         │                                                       │
│         │ 철수가 접속 시도                                       │
│         ▼                                                       │
│                                                                 │
│  서버: "철수 공개키 찾았다. 이걸로 암호화해서 보낼게"            │
│        → 철수 개인키로만 풀 수 있음                              │
│        → 영희, 민수 개인키로는 절대 못 풀음 (수학적으로 불가능)  │
└─────────────────────────────────────────────────────────────────┘
```

#### SSH vs 비밀번호 인증 비교

```
┌─────────────────────────────────────────────────────────────────┐
│  왜 SSH 키 인증이 비밀번호보다 안전한가?                         │
│                                                                 │
│  ┌────────────────┬─────────────────┬─────────────────────────┐ │
│  │                │ 비밀번호        │ SSH 키 (PEM)            │ │
│  ├────────────────┼─────────────────┼─────────────────────────┤ │
│  │ 네트워크 전송  │ 비밀번호 전송됨 │ 개인키 전송 안 됨       │ │
│  │ 브루트포스     │ 가능 (짧으니까) │ 불가능 (2048bit+)       │ │
│  │ 키 길이        │ 8~20자 정도     │ 수천 자                 │ │
│  │ 저장 방식      │ 사람 기억       │ 파일로 저장             │ │
│  │ 복잡도         │ 기억할 수 있어야│ 랜덤 (기억 불필요)      │ │
│  └────────────────┴─────────────────┴─────────────────────────┘ │
│                                                                 │
│  비밀번호: "password123" → 서버로 전송 → 탈취 가능              │
│  SSH 키:   개인키 자체는 전송 안 함 → 탈취 불가능               │
└─────────────────────────────────────────────────────────────────┘
```

#### PEM 파일 형식

```
┌─────────────────────────────────────────────────────────────────┐
│  PEM (Privacy-Enhanced Mail) 형식                               │
│                                                                 │
│  원래 이메일 암호화용으로 개발, 현재 키/인증서 저장에 사용       │
│  Base64 인코딩 + 헤더/푸터로 구성                               │
│                                                                 │
│  RSA 개인키 (비암호화):                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ -----BEGIN RSA PRIVATE KEY-----                          │    │
│  │ MIIEpAIBAAKCAQEA2Z3qX2BTLS4e...                          │    │
│  │ (Base64 인코딩된 DER 데이터)                              │    │
│  │ ...                                                       │    │
│  │ -----END RSA PRIVATE KEY-----                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  RSA 개인키 (암호화됨 - Passphrase 보호):                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ -----BEGIN RSA PRIVATE KEY-----                          │    │
│  │ Proc-Type: 4,ENCRYPTED                                   │    │
│  │ DEK-Info: AES-256-CBC,ABC123...                          │    │
│  │                                                           │    │
│  │ (암호화된 Base64 데이터)                                  │    │
│  │ -----END RSA PRIVATE KEY-----                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  PKCS#8 형식 (최신, 알고리즘 독립적):                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ -----BEGIN PRIVATE KEY-----          (비암호화)          │    │
│  │ -----BEGIN ENCRYPTED PRIVATE KEY----- (암호화)           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  공개키:                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ -----BEGIN PUBLIC KEY-----                               │    │
│  │ MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...                      │    │
│  │ -----END PUBLIC KEY-----                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  인증서:                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ -----BEGIN CERTIFICATE-----                              │    │
│  │ MIIDXTCCAkWgAwIBAgIJAJC1...                              │    │
│  │ -----END CERTIFICATE-----                                │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  키 파일 형식 비교                                               │
│                                                                 │
│  ┌────────────┬─────────────────────────────────────────────┐   │
│  │ 확장자     │ 설명                                         │   │
│  ├────────────┼─────────────────────────────────────────────┤   │
│  │ .pem       │ PEM 형식 (Base64, 텍스트)                   │   │
│  │ .der       │ DER 형식 (바이너리)                         │   │
│  │ .key       │ 개인키 (PEM 또는 DER)                       │   │
│  │ .pub       │ 공개키                                       │   │
│  │ .crt, .cer │ 인증서                                       │   │
│  │ .p12, .pfx │ PKCS#12: 개인키+인증서 번들 (암호화)        │   │
│  └────────────┴─────────────────────────────────────────────┘   │
│                                                                 │
│  AWS EC2 .pem 파일:                                              │
│  - EC2 인스턴스 생성 시 다운로드하는 키 페어                     │
│  - RSA 개인키가 PEM 형식으로 저장됨                              │
│  - 서버의 ~/.ssh/authorized_keys에 공개키 자동 등록             │
│  - chmod 400 필수 (소유자만 읽기)                               │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# SSH 키 생성 (다양한 알고리즘)
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa       # RSA 4096bit
ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519       # Ed25519 (추천, 더 빠르고 안전)
ssh-keygen -t ecdsa -b 521 -f ~/.ssh/id_ecdsa    # ECDSA

# PEM 파일 권한 설정 (필수!)
chmod 400 ~/.ssh/my_key.pem   # 소유자만 읽기
chmod 600 ~/.ssh/id_rsa       # 소유자만 읽기/쓰기

# SSH 연결
ssh -i ~/.ssh/my_key.pem ec2-user@ec2-xxx.compute.amazonaws.com

# PEM 파일 내용 확인
openssl rsa -in private.pem -text -noout         # RSA 키 정보
openssl x509 -in cert.pem -text -noout           # 인증서 정보

# 형식 변환
openssl rsa -in key.pem -outform DER -out key.der        # PEM → DER
openssl rsa -in key.der -inform DER -out key.pem         # DER → PEM
openssl pkcs12 -export -in cert.pem -inkey key.pem -out bundle.p12  # PKCS#12 생성
```

### 1.7.14 봉투 암호화 (Envelope Encryption)

```
┌─────────────────────────────────────────────────────────────────┐
│  봉투 암호화란?                                                  │
│                                                                 │
│  대용량 데이터를 효율적이고 안전하게 암호화하는 계층적 방식      │
│  "데이터를 암호화한 키"를 다시 암호화 → 봉투처럼 이중 포장      │
│                                                                 │
│  구조:                                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Master Key (KEK)                      │    │
│  │              Key Encryption Key - 최상위                │    │
│  │       (AWS KMS, HSM 등에 안전하게 보관)                  │    │
│  └───────────────────────┬─────────────────────────────────┘    │
│                          │ 암호화                               │
│                          ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Data Key (DEK)                        │    │
│  │              Data Encryption Key - 실제 암호화용         │    │
│  │           (대칭키, 매 데이터마다 새로 생성)              │    │
│  └───────────────────────┬─────────────────────────────────┘    │
│                          │ 암호화                               │
│                          ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Plain Data                            │    │
│  │              실제 암호화할 대용량 데이터                  │    │
│  │           (파일, 데이터베이스 레코드 등)                 │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  왜 봉투 암호화를 사용하는가?                                    │
│                                                                 │
│  문제 1: 대용량 데이터 + 비대칭키 암호화                         │
│  ────────────────────────────────────────                       │
│  비대칭키(RSA)로 1GB 파일 직접 암호화?                          │
│  → 매우 느림 (RSA는 수 KB/s)                                    │
│  → RSA는 블록 크기 제한 있음 (2048bit RSA = 최대 245바이트)     │
│                                                                 │
│  문제 2: 대칭키 직접 사용                                        │
│  ────────────────────────────────────────                       │
│  AES로 1GB 파일 암호화? → 빠름 (수 GB/s)                        │
│  하지만 키 관리가 어려움:                                        │
│  - 수천 개의 파일 = 수천 개의 키?                               │
│  - 모든 키를 어디에 안전하게 저장?                              │
│                                                                 │
│  해결: 봉투 암호화                                               │
│  ────────────────────────────────────────                       │
│  1. 대용량 데이터는 빠른 대칭키(DEK)로 암호화                    │
│  2. DEK는 작으니까(32바이트) 비대칭키(KEK)로 암호화             │
│  3. KEK 하나만 안전하게 보관하면 됨                              │
│                                                                 │
│  장점:                                                           │
│  ✅ 속도: 데이터는 AES로 빠르게 암호화                           │
│  ✅ 보안: DEK가 유출되어도 해당 데이터만 위험                    │
│  ✅ 키 관리: KEK 하나로 수천 개의 DEK 관리                       │
│  ✅ 키 교체: KEK만 교체하면 됨 (데이터 재암호화 불필요)          │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  봉투 암호화 동작 흐름                                           │
│                                                                 │
│  [암호화 과정]                                                   │
│                                                                 │
│  1. DEK 생성 (랜덤 대칭키, 256bit)                               │
│     DEK = random_bytes(32)                                      │
│                                                                 │
│  2. 데이터 암호화                                                │
│     Encrypted_Data = AES_Encrypt(Plain_Data, DEK)               │
│                                                                 │
│  3. DEK 암호화 (KEK 사용)                                        │
│     Encrypted_DEK = RSA_Encrypt(DEK, KEK_Public)                │
│                                                                 │
│  4. 저장                                                         │
│     ┌────────────────────────────────────────────────────┐      │
│     │  Encrypted_DEK (256 bytes)  │  Encrypted_Data      │      │
│     │  (RSA로 암호화된 DEK)       │  (AES로 암호화된     │      │
│     │                             │   대용량 데이터)     │      │
│     └────────────────────────────────────────────────────┘      │
│                                                                 │
│  5. 평문 DEK 메모리에서 즉시 삭제!                               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [복호화 과정]                                                   │
│                                                                 │
│  1. DEK 복호화 (KEK 개인키 사용)                                 │
│     DEK = RSA_Decrypt(Encrypted_DEK, KEK_Private)               │
│                                                                 │
│  2. 데이터 복호화                                                │
│     Plain_Data = AES_Decrypt(Encrypted_Data, DEK)               │
│                                                                 │
│  3. DEK 메모리에서 삭제                                          │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  AWS KMS 봉투 암호화 예시                                        │
│                                                                 │
│  AWS KMS (Key Management Service):                              │
│  - Master Key(CMK)를 HSM에 안전하게 보관                        │
│  - DEK 생성/암호화 API 제공                                      │
│  - CMK는 절대 AWS 밖으로 나가지 않음                            │
│                                                                 │
│  ┌─────────────┐         ┌─────────────┐                        │
│  │ Application │         │   AWS KMS   │                        │
│  │             │         │             │                        │
│  │             │──DEK 요청──▶│         │                        │
│  │             │         │  CMK로 DEK  │                        │
│  │             │◀─────────│  생성+암호화│                        │
│  │             │  {       │             │                        │
│  │             │   plaintext_dek,       │                        │
│  │             │   encrypted_dek        │                        │
│  │             │  }       │             │                        │
│  │             │         │             │                        │
│  │ AES로 데이터│         │             │                        │
│  │ 암호화      │         │             │                        │
│  │             │         │             │                        │
│  │ plaintext_  │         │             │                        │
│  │ dek 삭제    │         │             │                        │
│  └─────────────┘         └─────────────┘                        │
│                                                                 │
│  저장되는 것: encrypted_dek + encrypted_data                    │
│  KMS에 저장: CMK (절대 외부 노출 안 됨)                         │
└─────────────────────────────────────────────────────────────────┘
```

```typescript
// Node.js 봉투 암호화 구현 예시
import * as crypto from 'crypto';

interface EnvelopeEncrypted {
  encryptedDek: string;  // RSA로 암호화된 DEK
  iv: string;            // AES IV
  encryptedData: string; // AES로 암호화된 데이터
  authTag: string;       // GCM 인증 태그
}

class EnvelopeEncryption {
  private kekPublic: string;   // KEK 공개키
  private kekPrivate: string;  // KEK 개인키

  constructor(kekPublic: string, kekPrivate: string) {
    this.kekPublic = kekPublic;
    this.kekPrivate = kekPrivate;
  }

  // 암호화
  encrypt(plainData: Buffer): EnvelopeEncrypted {
    // 1. DEK 생성 (256bit 랜덤)
    const dek = crypto.randomBytes(32);

    // 2. DEK로 데이터 암호화 (AES-256-GCM)
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', dek, iv);
    const encryptedData = Buffer.concat([
      cipher.update(plainData),
      cipher.final(),
    ]);
    const authTag = cipher.getAuthTag();

    // 3. KEK 공개키로 DEK 암호화
    const encryptedDek = crypto.publicEncrypt(
      {
        key: this.kekPublic,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: 'sha256',
      },
      dek
    );

    // 4. 평문 DEK 메모리에서 삭제
    dek.fill(0);

    return {
      encryptedDek: encryptedDek.toString('base64'),
      iv: iv.toString('base64'),
      encryptedData: encryptedData.toString('base64'),
      authTag: authTag.toString('base64'),
    };
  }

  // 복호화
  decrypt(envelope: EnvelopeEncrypted): Buffer {
    // 1. KEK 개인키로 DEK 복호화
    const dek = crypto.privateDecrypt(
      {
        key: this.kekPrivate,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: 'sha256',
      },
      Buffer.from(envelope.encryptedDek, 'base64')
    );

    // 2. DEK로 데이터 복호화
    const decipher = crypto.createDecipheriv(
      'aes-256-gcm',
      dek,
      Buffer.from(envelope.iv, 'base64')
    );
    decipher.setAuthTag(Buffer.from(envelope.authTag, 'base64'));

    const decryptedData = Buffer.concat([
      decipher.update(Buffer.from(envelope.encryptedData, 'base64')),
      decipher.final(),
    ]);

    // 3. DEK 메모리에서 삭제
    dek.fill(0);

    return decryptedData;
  }
}

// AWS KMS 사용 예시
import { KMSClient, GenerateDataKeyCommand, DecryptCommand } from '@aws-sdk/client-kms';

class KmsEnvelopeEncryption {
  private kms: KMSClient;
  private keyId: string;  // KMS CMK ARN

  constructor(keyId: string) {
    this.kms = new KMSClient({ region: 'ap-northeast-2' });
    this.keyId = keyId;
  }

  async encrypt(plainData: Buffer): Promise<{
    encryptedDek: Buffer;
    encryptedData: Buffer;
    iv: Buffer;
  }> {
    // 1. KMS에서 DEK 생성 (평문 + 암호화된 DEK 둘 다 받음)
    const { Plaintext, CiphertextBlob } = await this.kms.send(
      new GenerateDataKeyCommand({
        KeyId: this.keyId,
        KeySpec: 'AES_256',
      })
    );

    // 2. 평문 DEK로 데이터 암호화
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', Plaintext!, iv);
    const encryptedData = Buffer.concat([
      cipher.update(plainData),
      cipher.final(),
      cipher.getAuthTag(),
    ]);

    // 3. 평문 DEK 삭제 (중요!)
    Plaintext!.fill(0);

    return {
      encryptedDek: Buffer.from(CiphertextBlob!),  // 암호화된 DEK
      encryptedData,
      iv,
    };
  }

  async decrypt(encryptedDek: Buffer, encryptedData: Buffer, iv: Buffer): Promise<Buffer> {
    // 1. KMS에서 DEK 복호화
    const { Plaintext } = await this.kms.send(
      new DecryptCommand({
        CiphertextBlob: encryptedDek,
      })
    );

    // 2. DEK로 데이터 복호화
    const authTag = encryptedData.slice(-16);
    const ciphertext = encryptedData.slice(0, -16);

    const decipher = crypto.createDecipheriv('aes-256-gcm', Plaintext!, iv);
    decipher.setAuthTag(authTag);

    const decryptedData = Buffer.concat([
      decipher.update(ciphertext),
      decipher.final(),
    ]);

    // 3. DEK 삭제
    Plaintext!.fill(0);

    return decryptedData;
  }
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│  봉투 암호화 사용 사례                                           │
│                                                                 │
│  1. AWS S3 서버 측 암호화 (SSE-KMS)                              │
│     - S3가 자동으로 봉투 암호화 수행                             │
│     - 객체마다 고유 DEK 생성                                     │
│     - DEK는 KMS CMK로 암호화                                     │
│                                                                 │
│  2. 데이터베이스 필드 암호화                                      │
│     - 민감 정보(주민번호, 카드번호) 암호화                       │
│     - 레코드마다 또는 테이블마다 DEK 사용                        │
│                                                                 │
│  3. 백업 암호화                                                  │
│     - 백업 파일마다 새 DEK 생성                                  │
│     - 백업과 함께 암호화된 DEK 저장                              │
│                                                                 │
│  4. 메시지 암호화 (E2E)                                          │
│     - 메시지마다 새 DEK 생성                                     │
│     - 수신자 공개키로 DEK 암호화                                 │
│                                                                 │
│  5. 디스크 암호화 (LUKS, BitLocker)                              │
│     - 디스크 전체를 DEK로 암호화                                 │
│     - DEK를 패스워드 또는 TPM으로 보호                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  면접 포인트: SSH/PEM/봉투 암호화                                 │
│                                                                 │
│  Q: SSH 키 인증이 비밀번호보다 안전한 이유?                      │
│  A: 1) 개인키가 네트워크로 전송 안 됨                            │
│     2) 브루트포스 공격 불가 (키 길이 2048+bit)                   │
│     3) 키에 Passphrase 추가 가능 (2단계)                        │
│                                                                 │
│  Q: PEM 파일이란?                                                │
│  A: Base64로 인코딩된 키/인증서 형식.                            │
│     -----BEGIN/END 헤더로 구분                                   │
│                                                                 │
│  Q: 왜 chmod 400/600 권한이 필요한가?                            │
│  A: 개인키 파일은 소유자만 접근해야 함.                          │
│     SSH는 권한이 느슨하면 연결 거부함 (보안)                     │
│                                                                 │
│  Q: 봉투 암호화의 핵심 개념?                                     │
│  A: 1) DEK로 데이터 암호화 (빠른 대칭키)                         │
│     2) KEK로 DEK 암호화 (안전한 비대칭키)                        │
│     3) KEK만 안전하게 관리하면 됨                                │
│                                                                 │
│  Q: 봉투 암호화의 장점?                                          │
│  A: 1) 속도: 데이터는 AES로 빠르게                               │
│     2) 키 관리: 하나의 KEK로 수천 DEK 관리                       │
│     3) 키 교체: KEK만 교체, 데이터 재암호화 불필요               │
│     4) 보안: DEK 유출 시 피해 범위 제한                          │
└─────────────────────────────────────────────────────────────────┘
```

### 1.8 DNS (Domain Name System)

```
┌─────────────────────────────────────────────────────────────────┐
│  DNS 조회 과정                                                   │
│                                                                 │
│  1. 브라우저 캐시 확인                                           │
│  2. OS 캐시 확인 (/etc/hosts)                                   │
│  3. Local DNS 서버 (ISP) 질의                                   │
│                                                                 │
│     Client → Local DNS → Root DNS (.com 관리 서버 알려줌)       │
│                        → TLD DNS (.com, example.com NS 알려줌)  │
│                        → Authoritative DNS (IP 알려줌)         │
│                                                                 │
│  DNS 레코드 타입:                                                │
│  - A: 도메인 → IPv4                                             │
│  - AAAA: 도메인 → IPv6                                          │
│  - CNAME: 도메인 → 다른 도메인 (별칭)                           │
│  - MX: 메일 서버                                                │
│  - NS: 네임서버                                                  │
│  - TXT: 텍스트 (SPF, DKIM 등)                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 1.9 로드 밸런싱

```
┌─────────────────────────────────────────────────────────────────┐
│  L4 로드밸런서 (Transport Layer)                                │
│                                                                 │
│  - TCP/UDP 레벨에서 동작                                        │
│  - IP + Port 기반 라우팅                                        │
│  - 빠름, 단순                                                    │
│  - 애플리케이션 내용 모름                                        │
│                                                                 │
│  Client ──▶ L4 LB ──┬──▶ Server 1                              │
│                     ├──▶ Server 2                              │
│                     └──▶ Server 3                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  L7 로드밸런서 (Application Layer)                              │
│                                                                 │
│  - HTTP 레벨에서 동작                                           │
│  - URL, Header, Cookie 기반 라우팅 가능                         │
│  - SSL Termination                                              │
│  - 캐싱, 압축 가능                                               │
│  - 더 많은 리소스 사용                                           │
│                                                                 │
│  Client ──▶ L7 LB ──┬──▶ /api/* → API Servers                  │
│                     ├──▶ /static/* → CDN                       │
│                     └──▶ /* → Web Servers                      │
└─────────────────────────────────────────────────────────────────┘

로드밸런싱 알고리즘:
- Round Robin: 순차적 분배
- Weighted Round Robin: 가중치 기반
- Least Connections: 연결 수 적은 서버로
- IP Hash: 클라이언트 IP 기반 (세션 유지)
- Least Response Time: 응답 시간 빠른 서버로
```

#### 1.9.1 WebSocket/소켓 통신과 Sticky Session (IP Hash)

```
┌─────────────────────────────────────────────────────────────────┐
│  왜 WebSocket에서 Sticky Session이 필요한가?                     │
│                                                                 │
│  HTTP (Stateless):                                               │
│  ┌────────┐     ┌────────┐                                      │
│  │ Client │────▶│ LB     │────▶ Server 1 (요청 1)               │
│  │        │────▶│        │────▶ Server 2 (요청 2)  ← OK!        │
│  │        │────▶│        │────▶ Server 3 (요청 3)               │
│  └────────┘     └────────┘                                      │
│  매 요청이 독립적 → 어느 서버로 가도 상관없음                    │
│                                                                 │
│  WebSocket (Stateful, 지속 연결):                                │
│  ┌────────┐     ┌────────┐     ┌──────────┐                     │
│  │ Client │═════│ LB     │═════│ Server 1 │ 연결 상태 유지      │
│  │        │     │        │     │ - 세션 데이터                  │
│  │        │     │        │     │ - 구독 정보                    │
│  │        │     │        │     │ - 채팅방 컨텍스트              │
│  └────────┘     └────────┘     └──────────┘                     │
│                                                                 │
│  문제: Round Robin으로 다른 서버에 연결되면?                     │
│  → 기존 연결 끊김, 상태 손실, 재연결 시 다른 서버 배정           │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  문제 시나리오: WebSocket + Round Robin                          │
│                                                                 │
│  1. 초기 연결:                                                   │
│     Client A ──WebSocket──▶ LB ──▶ Server 1 (연결 수립)         │
│     Server 1에 Client A의 상태 저장 (채팅방, 구독 등)           │
│                                                                 │
│  2. 연결 끊김 후 재연결:                                         │
│     Client A ──WebSocket──▶ LB ──▶ Server 2 (Round Robin)       │
│                                                                 │
│  3. 결과:                                                        │
│     ❌ Server 2는 Client A의 상태를 모름                         │
│     ❌ 이전 채팅방 정보 없음                                      │
│     ❌ 구독했던 이벤트 수신 불가                                  │
│     ❌ 메시지 유실 가능                                           │
│                                                                 │
│  4. Socket.IO 폴링 문제:                                         │
│     Socket.IO는 WebSocket 연결 전 HTTP Long-Polling 사용        │
│     Polling 요청 → Server 1                                     │
│     Upgrade 요청 → Server 2 (다른 서버!)                        │
│     → "Session ID unknown" 에러 발생                            │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  해결: IP Hash (Sticky Session)                                  │
│                                                                 │
│  동작 원리:                                                      │
│  server_index = hash(client_ip) % number_of_servers             │
│                                                                 │
│  Client A (IP: 1.2.3.4)                                         │
│    hash("1.2.3.4") % 3 = 1 → 항상 Server 1로                    │
│                                                                 │
│  Client B (IP: 5.6.7.8)                                         │
│    hash("5.6.7.8") % 3 = 2 → 항상 Server 2로                    │
│                                                                 │
│  ┌────────┐                    ┌──────────┐                     │
│  │Client A│═══════════════════▶│ Server 1 │ (항상 동일)         │
│  │1.2.3.4 │     ┌────────┐     └──────────┘                     │
│  └────────┘     │   LB   │                                      │
│  ┌────────┐     │IP Hash │     ┌──────────┐                     │
│  │Client B│═══════════════════▶│ Server 2 │ (항상 동일)         │
│  │5.6.7.8 │     └────────┘     └──────────┘                     │
│  └────────┘                                                     │
│                                                                 │
│  결과:                                                           │
│  ✅ 재연결 시에도 같은 서버로 라우팅                              │
│  ✅ 서버의 세션 상태 유지                                         │
│  ✅ Socket.IO 폴링 → WebSocket 업그레이드 정상 동작              │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  IP Hash의 한계와 대안                                           │
│                                                                 │
│  IP Hash 한계:                                                   │
│  1. NAT 환경: 같은 회사/공유기 사용자들이 같은 서버로 몰림       │
│  2. 서버 추가/제거 시 해시 재분배 → 기존 연결 끊김               │
│  3. 불균형 분산: 특정 서버에 부하 집중 가능                      │
│                                                                 │
│  대안 1: Cookie 기반 Sticky Session                              │
│  ┌────────────────────────────────────────────────────────┐     │
│  │ Set-Cookie: SERVERID=server1; Path=/                    │     │
│  │ 이후 요청마다 Cookie로 서버 식별                         │     │
│  │ 장점: NAT 환경에서도 개별 사용자 구분                    │     │
│  │ 단점: WebSocket에서는 초기 Handshake에만 쿠키 전송       │     │
│  └────────────────────────────────────────────────────────┘     │
│                                                                 │
│  대안 2: Consistent Hashing                                      │
│  - 서버 추가/제거 시 일부 키만 재분배                            │
│  - 대부분의 기존 연결 유지                                       │
│                                                                 │
│  대안 3: 외부 세션 저장소 (Redis)                                │
│  ┌────────────────────────────────────────────────────────┐     │
│  │         ┌─────────┐                                     │     │
│  │ Server1─┤  Redis  ├─Server2                             │     │
│  │         │ (세션)  │                                     │     │
│  │ Server3─┤         ├─Server4                             │     │
│  │         └─────────┘                                     │     │
│  │ 모든 서버가 세션 공유 → Sticky 불필요                   │     │
│  │ Socket.IO: socket.io-redis adapter 사용                 │     │
│  └────────────────────────────────────────────────────────┘     │
│                                                                 │
│  대안 4: Pub/Sub 메시지 브로드캐스트                             │
│  - 서버 간 이벤트 동기화                                         │
│  - 어느 서버에 연결되어도 메시지 수신 가능                       │
└─────────────────────────────────────────────────────────────────┘
```

```
# Nginx IP Hash 설정
upstream websocket_servers {
    ip_hash;  # Sticky Session 활성화
    server 10.0.0.1:3000;
    server 10.0.0.2:3000;
    server 10.0.0.3:3000;
}

server {
    location /socket.io/ {
        proxy_pass http://websocket_servers;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# HAProxy Sticky Session (Cookie 기반)
backend websocket_backend
    balance roundrobin
    cookie SERVERID insert indirect nocache
    server server1 10.0.0.1:3000 check cookie s1
    server server2 10.0.0.2:3000 check cookie s2
    server server3 10.0.0.3:3000 check cookie s3
```

```typescript
// Node.js Socket.IO with Redis Adapter (Sticky 불필요 방식)
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

const pubClient = createClient({ url: 'redis://localhost:6379' });
const subClient = pubClient.duplicate();

await Promise.all([pubClient.connect(), subClient.connect()]);

const io = new Server(server, {
  adapter: createAdapter(pubClient, subClient),
});

// 이제 어느 서버에 연결되어도 모든 클라이언트에게 메시지 전달 가능
io.emit('broadcast', { msg: '모든 서버의 클라이언트가 수신' });

// 특정 Room으로 메시지 (서버 간 동기화됨)
io.to('room1').emit('message', { msg: 'room1 메시지' });
```

```
┌─────────────────────────────────────────────────────────────────┐
│  실무 권장 구성                                                  │
│                                                                 │
│  소규모 (서버 2-3대):                                            │
│  → IP Hash로 충분                                                │
│                                                                 │
│  중규모 (서버 4대 이상):                                         │
│  → IP Hash + Redis Pub/Sub                                      │
│  → 서버 장애 시에도 다른 서버에서 이벤트 수신 가능               │
│                                                                 │
│  대규모 (수십 대):                                                │
│  → Redis Cluster + Consistent Hashing                           │
│  → Kubernetes: Service Mesh (Istio)의 Session Affinity          │
│                                                                 │
│  K8s Sticky Session 설정:                                        │
│  apiVersion: v1                                                  │
│  kind: Service                                                   │
│  spec:                                                           │
│    sessionAffinity: ClientIP                                     │
│    sessionAffinityConfig:                                        │
│      clientIP:                                                   │
│        timeoutSeconds: 3600                                      │
└─────────────────────────────────────────────────────────────────┘
```

### 1.10 캐싱 전략

```
┌─────────────────────────────────────────────────────────────────┐
│  HTTP 캐싱 헤더                                                  │
│                                                                 │
│  Cache-Control:                                                 │
│  - max-age=3600: 3600초 동안 캐시                               │
│  - no-cache: 매번 서버에 유효성 확인                            │
│  - no-store: 캐시 저장 안 함                                    │
│  - private: 브라우저만 캐시 (CDN X)                             │
│  - public: 모든 곳에서 캐시 가능                                │
│                                                                 │
│  조건부 요청:                                                    │
│  - ETag + If-None-Match: 컨텐츠 해시 비교                       │
│  - Last-Modified + If-Modified-Since: 수정 시간 비교           │
│                                                                 │
│  304 Not Modified: 캐시 사용해도 됨                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  CDN (Content Delivery Network)                                 │
│                                                                 │
│                        Origin Server                            │
│                             │                                   │
│           ┌─────────────────┼─────────────────┐                │
│           │                 │                 │                 │
│        Edge 1            Edge 2            Edge 3               │
│       (서울)            (도쿄)            (싱가포르)             │
│           │                 │                 │                 │
│        User A           User B            User C                │
│                                                                 │
│  장점:                                                           │
│  - 지연 시간 감소 (가까운 Edge 서버)                            │
│  - Origin 서버 부하 감소                                        │
│  - DDoS 방어                                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 1.11 Node.js와 네트워크

**Node.js HTTP 서버의 내부 동작:**

```
TCP 패킷 도착
    │
    ▼
OS 커널: 소켓 버퍼에 저장
    │
    ▼
epoll/kqueue: 이벤트 감지
    │
    ▼
libuv: uv_read_start() 콜백
    │
    ▼
llhttp: HTTP 파싱 (C)
    │
    ▼
JavaScript: 'request' 이벤트
```

**Keep-Alive 설정:**

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  res.end('Hello');
});

// Keep-Alive 타임아웃 설정
server.keepAliveTimeout = 5000;  // 5초
server.headersTimeout = 60000;   // 60초

server.listen(3000);
```

### 1.12 면접 포인트: 네트워크

| 질문                    | 핵심 답변                                                                  |
| ----------------------- | -------------------------------------------------------------------------- |
| TCP vs UDP?             | TCP: 연결 지향, 신뢰성, 순서 보장. UDP: 비연결, 빠름, 손실 가능            |
| 3-way handshake 왜 3번? | 양방향 통신 확인 + 시퀀스 번호 동기화. 2번이면 서버가 클라이언트 상태 모름 |
| HTTP/2 개선점?          | Multiplexing, Header 압축, Server Push. TCP HOL Blocking 한계              |
| HTTP/3 특징?            | UDP(QUIC) 기반, 스트림별 독립 흐름 제어, 0-RTT, 연결 마이그레이션          |
| HTTPS 동작?             | TLS Handshake로 키 교환 → 대칭키 암호화 통신                              |
| L4 vs L7 로드밸런서?    | L4: IP/Port 기반, 빠름. L7: HTTP 내용 기반, 유연함                         |

---

## 2. 자료구조와 알고리즘

### 2.1 시간 복잡도 (Big-O)

```
┌─────────────────────────────────────────────────────────────────┐
│  시간 복잡도 비교 (n = 1,000,000)                               │
│                                                                 │
│  O(1)        : 1                     상수 시간                  │
│  O(log n)    : 20                    이진 탐색                  │
│  O(n)        : 1,000,000             선형 탐색                  │
│  O(n log n)  : 20,000,000            정렬 (Merge, Quick)       │
│  O(n²)       : 1,000,000,000,000     버블 정렬                  │
│  O(2^n)      : 우주가 끝날 때까지     부분집합                   │
│                                                                 │
│  성능 순서: O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)│
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 배열 vs 연결 리스트

```
┌─────────────────────────────────────────────────────────────────┐
│  배열 (Array)                                                    │
│                                                                 │
│  메모리: [1][2][3][4][5] (연속)                                 │
│                                                                 │
│  연산 복잡도:                                                    │
│  - 인덱스 접근: O(1)                                            │
│  - 맨 끝 삽입/삭제: O(1)                                        │
│  - 중간 삽입/삭제: O(n) (이동 필요)                             │
│  - 검색: O(n) (정렬되면 O(log n))                               │
│                                                                 │
│  장점: 캐시 지역성, 랜덤 접근                                    │
│  단점: 크기 고정, 중간 삽입/삭제 느림                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  연결 리스트 (Linked List)                                      │
│                                                                 │
│  메모리: [1|→]──▶[2|→]──▶[3|→]──▶[4|→]──▶[5|∅]                 │
│                                                                 │
│  연산 복잡도:                                                    │
│  - 인덱스 접근: O(n)                                            │
│  - 맨 앞/뒤 삽입/삭제: O(1) (포인터만 변경)                     │
│  - 중간 삽입/삭제: O(1) (위치 찾으면)                           │
│  - 검색: O(n)                                                   │
│                                                                 │
│  장점: 동적 크기, 삽입/삭제 빠름                                 │
│  단점: 메모리 오버헤드, 캐시 미스                                │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 스택 (Stack)

LIFO (Last In First Out)

```typescript
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }
}

// 활용 사례:
// - 함수 호출 스택
// - 괄호 매칭
// - 뒤로 가기
// - DFS
```

**괄호 매칭 예제:**

```typescript
function isValidParentheses(s: string): boolean {
  const stack: string[] = [];
  const pairs: Record<string, string> = {
    ')': '(',
    ']': '[',
    '}': '{'
  };

  for (const char of s) {
    if (char === '(' || char === '[' || char === '{') {
      stack.push(char);
    } else {
      if (stack.pop() !== pairs[char]) {
        return false;
      }
    }
  }

  return stack.length === 0;
}

// isValidParentheses("([]){}") → true
// isValidParentheses("([)]")  → false
```

### 2.4 큐 (Queue)

FIFO (First In First Out)

```typescript
class Queue<T> {
  private items: T[] = [];

  enqueue(item: T): void {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();  // O(n) - 실제로는 링버퍼나 연결리스트 사용
  }

  front(): T | undefined {
    return this.items[0];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }
}

// 활용 사례:
// - BFS
// - 작업 대기열
// - 버퍼
// - 이벤트 루프 태스크 큐
```

**원형 큐 (효율적인 구현):**

```typescript
class CircularQueue<T> {
  private items: (T | undefined)[];
  private head: number = 0;
  private tail: number = 0;
  private count: number = 0;
  private capacity: number;

  constructor(capacity: number) {
    this.capacity = capacity;
    this.items = new Array(capacity);
  }

  enqueue(item: T): boolean {
    if (this.isFull()) return false;
    this.items[this.tail] = item;
    this.tail = (this.tail + 1) % this.capacity;
    this.count++;
    return true;
  }

  dequeue(): T | undefined {
    if (this.isEmpty()) return undefined;
    const item = this.items[this.head];
    this.items[this.head] = undefined;
    this.head = (this.head + 1) % this.capacity;
    this.count--;
    return item;
  }

  isEmpty(): boolean {
    return this.count === 0;
  }

  isFull(): boolean {
    return this.count === this.capacity;
  }
}
```

### 2.5 해시 테이블 (Hash Table)

```typescript
class HashTable<K, V> {
  private buckets: Array<Array<[K, V]>>;
  private size: number;

  constructor(size: number = 53) {
    this.size = size;
    this.buckets = Array.from({ length: size }, () => []);
  }

  private hash(key: K): number {
    const str = String(key);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = (hash * 31 + str.charCodeAt(i)) % this.size;
    }
    return hash;
  }

  set(key: K, value: V): void {
    const index = this.hash(key);
    const bucket = this.buckets[index];

    for (const pair of bucket) {
      if (pair[0] === key) {
        pair[1] = value;
        return;
      }
    }
    bucket.push([key, value]);
  }

  get(key: K): V | undefined {
    const index = this.hash(key);
    const bucket = this.buckets[index];

    for (const pair of bucket) {
      if (pair[0] === key) {
        return pair[1];
      }
    }
    return undefined;
  }

  delete(key: K): boolean {
    const index = this.hash(key);
    const bucket = this.buckets[index];

    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i][0] === key) {
        bucket.splice(i, 1);
        return true;
      }
    }
    return false;
  }
}
```

**충돌 해결 방법:**

```
┌─────────────────────────────────────────────────────────────────┐
│  1. Chaining (체이닝)                                           │
│                                                                 │
│  버킷:  [0] → [A] → [B]                                        │
│         [1] → [C]                                               │
│         [2] → null                                              │
│         [3] → [D] → [E] → [F]                                  │
│                                                                 │
│  장점: 구현 간단, 적재율 1 이상 가능                            │
│  단점: 메모리 오버헤드, 캐시 미스                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  2. Open Addressing (개방 주소법)                               │
│                                                                 │
│  Linear Probing: 충돌 시 다음 빈 칸                             │
│  hash(A) = 3 → 버킷[3]                                         │
│  hash(B) = 3 → 충돌 → 버킷[4]                                  │
│  hash(C) = 3 → 충돌 → 버킷[5]                                  │
│                                                                 │
│  장점: 캐시 지역성                                               │
│  단점: 클러스터링, 삭제 복잡                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6 힙 (Heap)

```typescript
class MinHeap<T> {
  private heap: T[] = [];

  constructor(private compare: (a: T, b: T) => number = (a, b) => (a as any) - (b as any)) {}

  private parent(i: number): number {
    return Math.floor((i - 1) / 2);
  }

  private leftChild(i: number): number {
    return 2 * i + 1;
  }

  private rightChild(i: number): number {
    return 2 * i + 2;
  }

  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  insert(value: T): void {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }

  private bubbleUp(index: number): void {
    while (index > 0) {
      const parentIdx = this.parent(index);
      if (this.compare(this.heap[index], this.heap[parentIdx]) >= 0) break;
      this.swap(index, parentIdx);
      index = parentIdx;
    }
  }

  extractMin(): T | undefined {
    if (this.heap.length === 0) return undefined;
    if (this.heap.length === 1) return this.heap.pop();

    const min = this.heap[0];
    this.heap[0] = this.heap.pop()!;
    this.bubbleDown(0);
    return min;
  }

  private bubbleDown(index: number): void {
    const length = this.heap.length;

    while (true) {
      let smallest = index;
      const left = this.leftChild(index);
      const right = this.rightChild(index);

      if (left < length && this.compare(this.heap[left], this.heap[smallest]) < 0) {
        smallest = left;
      }
      if (right < length && this.compare(this.heap[right], this.heap[smallest]) < 0) {
        smallest = right;
      }

      if (smallest === index) break;
      this.swap(index, smallest);
      index = smallest;
    }
  }

  peek(): T | undefined {
    return this.heap[0];
  }

  size(): number {
    return this.heap.length;
  }
}

// 활용 사례:
// - 우선순위 큐
// - 힙 정렬
// - 타이머 관리 (Node.js libuv)
// - 다익스트라 알고리즘
```

### 2.7 이진 탐색 트리 (BST)

```typescript
class TreeNode<T> {
  value: T;
  left: TreeNode<T> | null = null;
  right: TreeNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class BinarySearchTree<T> {
  root: TreeNode<T> | null = null;

  insert(value: T): void {
    const newNode = new TreeNode(value);

    if (!this.root) {
      this.root = newNode;
      return;
    }

    let current = this.root;
    while (true) {
      if (value < current.value) {
        if (!current.left) {
          current.left = newNode;
          return;
        }
        current = current.left;
      } else {
        if (!current.right) {
          current.right = newNode;
          return;
        }
        current = current.right;
      }
    }
  }

  search(value: T): TreeNode<T> | null {
    let current = this.root;

    while (current) {
      if (value === current.value) return current;
      current = value < current.value ? current.left : current.right;
    }

    return null;
  }

  // 중위 순회 (오름차순 정렬)
  inorderTraversal(node: TreeNode<T> | null = this.root, result: T[] = []): T[] {
    if (node) {
      this.inorderTraversal(node.left, result);
      result.push(node.value);
      this.inorderTraversal(node.right, result);
    }
    return result;
  }
}

// BST 연산 복잡도:
// 평균: O(log n)
// 최악 (편향): O(n)
// → AVL, Red-Black Tree로 균형 유지
```

### 2.8 그래프 (Graph)

```typescript
class Graph {
  private adjacencyList: Map<string, string[]> = new Map();

  addVertex(vertex: string): void {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }

  addEdge(v1: string, v2: string): void {
    this.adjacencyList.get(v1)?.push(v2);
    this.adjacencyList.get(v2)?.push(v1);  // 무방향 그래프
  }

  // BFS (너비 우선 탐색)
  bfs(start: string): string[] {
    const visited = new Set<string>();
    const result: string[] = [];
    const queue: string[] = [start];

    visited.add(start);

    while (queue.length > 0) {
      const vertex = queue.shift()!;
      result.push(vertex);

      for (const neighbor of this.adjacencyList.get(vertex) || []) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }

    return result;
  }

  // DFS (깊이 우선 탐색)
  dfs(start: string): string[] {
    const visited = new Set<string>();
    const result: string[] = [];

    const dfsRecursive = (vertex: string) => {
      visited.add(vertex);
      result.push(vertex);

      for (const neighbor of this.adjacencyList.get(vertex) || []) {
        if (!visited.has(neighbor)) {
          dfsRecursive(neighbor);
        }
      }
    };

    dfsRecursive(start);
    return result;
  }
}

// BFS 활용: 최단 경로, 레벨 순회
// DFS 활용: 경로 찾기, 사이클 감지, 위상 정렬
```

### 2.9 정렬 알고리즘

**Quick Sort:**

```typescript
function quickSort(arr: number[], low: number = 0, high: number = arr.length - 1): number[] {
  if (low < high) {
    const pivotIndex = partition(arr, low, high);
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
  }
  return arr;
}

function partition(arr: number[], low: number, high: number): number {
  const pivot = arr[high];
  let i = low - 1;

  for (let j = low; j < high; j++) {
    if (arr[j] < pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}

// 시간 복잡도: 평균 O(n log n), 최악 O(n²)
// 공간 복잡도: O(log n) (재귀 스택)
// 특징: 불안정 정렬, in-place
```

**Merge Sort:**

```typescript
function mergeSort(arr: number[]): number[] {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left: number[], right: number[]): number[] {
  const result: number[] = [];
  let i = 0, j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}

// 시간 복잡도: O(n log n) (항상)
// 공간 복잡도: O(n)
// 특징: 안정 정렬
```

**정렬 알고리즘 비교:**

| 알고리즘   | 평균       | 최악       | 공간     | 안정성 |
| ---------- | ---------- | ---------- | -------- | ------ |
| Quick Sort | O(n log n) | O(n²)     | O(log n) | 불안정 |
| Merge Sort | O(n log n) | O(n log n) | O(n)     | 안정   |
| Heap Sort  | O(n log n) | O(n log n) | O(1)     | 불안정 |
| Tim Sort   | O(n log n) | O(n log n) | O(n)     | 안정   |

### 2.10 이진 탐색

```typescript
function binarySearch(arr: number[], target: number): number {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;  // 못 찾음
}

// Lower Bound (target 이상인 첫 위치)
function lowerBound(arr: number[], target: number): number {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return left;
}

// Upper Bound (target 초과인 첫 위치)
function upperBound(arr: number[], target: number): number {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] <= target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return left;
}

// 시간 복잡도: O(log n)
```

### 2.11 동적 프로그래밍 (DP)

**피보나치 (Top-Down vs Bottom-Up):**

```typescript
// Top-Down (Memoization)
function fibMemo(n: number, memo: Map<number, number> = new Map()): number {
  if (n <= 1) return n;
  if (memo.has(n)) return memo.get(n)!;

  const result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  memo.set(n, result);
  return result;
}

// Bottom-Up (Tabulation)
function fibTab(n: number): number {
  if (n <= 1) return n;

  const dp: number[] = [0, 1];
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}

// 공간 최적화
function fibOptimized(n: number): number {
  if (n <= 1) return n;

  let prev2 = 0, prev1 = 1;
  for (let i = 2; i <= n; i++) {
    const current = prev1 + prev2;
    prev2 = prev1;
    prev1 = current;
  }
  return prev1;
}
```

**배낭 문제 (0/1 Knapsack):**

```typescript
function knapsack(weights: number[], values: number[], capacity: number): number {
  const n = weights.length;
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    Array(capacity + 1).fill(0)
  );

  for (let i = 1; i <= n; i++) {
    for (let w = 0; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          dp[i - 1][w],  // 안 넣는 경우
          dp[i - 1][w - weights[i - 1]] + values[i - 1]  // 넣는 경우
        );
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }

  return dp[n][capacity];
}

// 시간 복잡도: O(n * capacity)
// 공간 복잡도: O(n * capacity) → 1차원으로 최적화 가능
```

**최장 공통 부분 수열 (LCS):**

```typescript
function longestCommonSubsequence(text1: string, text2: string): number {
  const m = text1.length;
  const n = text2.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () =>
    Array(n + 1).fill(0)
  );

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

// 시간 복잡도: O(m * n)
```

### 2.12 최단 경로 알고리즘

**다익스트라 (Dijkstra):**

```typescript
function dijkstra(
  graph: Map<string, Map<string, number>>,
  start: string
): Map<string, number> {
  const distances = new Map<string, number>();
  const visited = new Set<string>();
  const pq = new MinHeap<{ node: string; dist: number }>(
    (a, b) => a.dist - b.dist
  );

  // 초기화
  for (const node of graph.keys()) {
    distances.set(node, node === start ? 0 : Infinity);
  }
  pq.insert({ node: start, dist: 0 });

  while (pq.size() > 0) {
    const { node, dist } = pq.extractMin()!;

    if (visited.has(node)) continue;
    visited.add(node);

    for (const [neighbor, weight] of graph.get(node) || []) {
      const newDist = dist + weight;
      if (newDist < distances.get(neighbor)!) {
        distances.set(neighbor, newDist);
        pq.insert({ node: neighbor, dist: newDist });
      }
    }
  }

  return distances;
}

// 시간 복잡도: O((V + E) log V) with 힙
// 제약: 음수 가중치 불가
```

**벨만-포드 (Bellman-Ford):**

```typescript
function bellmanFord(
  edges: Array<[string, string, number]>,
  vertices: string[],
  start: string
): Map<string, number> | null {
  const distances = new Map<string, number>();

  // 초기화
  for (const v of vertices) {
    distances.set(v, v === start ? 0 : Infinity);
  }

  // V-1번 반복
  for (let i = 0; i < vertices.length - 1; i++) {
    for (const [u, v, weight] of edges) {
      const distU = distances.get(u)!;
      const distV = distances.get(v)!;
      if (distU + weight < distV) {
        distances.set(v, distU + weight);
      }
    }
  }

  // 음수 사이클 체크
  for (const [u, v, weight] of edges) {
    if (distances.get(u)! + weight < distances.get(v)!) {
      return null;  // 음수 사이클 존재
    }
  }

  return distances;
}

// 시간 복잡도: O(V * E)
// 장점: 음수 가중치 처리 가능
```

### 2.13 면접 포인트: 자료구조/알고리즘

| 질문                 | 핵심 답변                                                                   |
| -------------------- | --------------------------------------------------------------------------- |
| 배열 vs 연결 리스트? | 배열: 랜덤 접근 O(1), 삽입/삭제 O(n). 연결 리스트: 반대                     |
| 해시 충돌 해결?      | Chaining (연결 리스트) 또는 Open Addressing (선형/이차 탐사)                |
| Quick vs Merge Sort? | Quick: 평균 빠름, 불안정, in-place. Merge: 항상 O(n log n), 안정, O(n) 공간 |
| BFS vs DFS?          | BFS: 최단 경로, 레벨 순회. DFS: 모든 경로, 사이클 감지                      |
| DP 접근법?           | 중복 부분 문제 + 최적 부분 구조 → 점화식 → Top-Down 또는 Bottom-Up        |
| Dijkstra 제약?       | 음수 가중치 불가. 음수 있으면 Bellman-Ford 사용                             |

---

## 3. 운영체제

### 3.1 프로세스 vs 스레드

```
┌─────────────────────────────────────────────────────────────────┐
│  프로세스 (Process)                                              │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  Code (Text)   │  프로그램 코드                              ││
│  │  Data          │  전역 변수, 정적 변수                       ││
│  │  Heap          │  동적 할당 메모리                           ││
│  │  Stack         │  함수 호출, 지역 변수                       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  - 독립적인 메모리 공간 (4GB 가상 메모리)                       │
│  - 프로세스 간 통신 (IPC) 필요: 파이프, 소켓, 공유 메모리      │
│  - 생성 비용 높음                                               │
│  - 하나가 죽어도 다른 프로세스 영향 없음                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  스레드 (Thread)                                                 │
│                                                                 │
│  프로세스 내:                                                    │
│  ┌──────────────────────────────────────────────┐              │
│  │  Code, Data, Heap  (공유)                    │              │
│  ├──────────────────────────────────────────────┤              │
│  │  Thread 1    │  Thread 2    │  Thread 3     │              │
│  │  Stack       │  Stack       │  Stack        │  ← 독립      │
│  │  Registers   │  Registers   │  Registers    │  ← 독립      │
│  │  PC          │  PC          │  PC           │  ← 독립      │
│  └──────────────────────────────────────────────┘              │
│                                                                 │
│  - Code, Data, Heap 공유 (동기화 필요)                         │
│  - Stack, Registers 독립                                        │
│  - 생성 비용 낮음                                               │
│  - Context Switch 빠름                                          │
│  - 하나가 죽으면 전체 프로세스 영향                             │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 프로세스 상태

```
                    ┌─────────────────┐
                    │                 │
               new  │    admitted     │  exit
                ┌───┴───┐         ┌───┴───┐
                │       │         │       │
                ▼       │         │       ▼
┌───────┐     ┌───────────────────────────────┐     ┌───────────┐
│  New  │────▶│            Ready              │────▶│Terminated │
└───────┘     └───────────────────────────────┘     └───────────┘
                │                 ▲
                │ scheduler      │ I/O or event
                │ dispatch       │ completion
                ▼                │
              ┌───────────────────────────────┐
              │           Running             │
              └───────────────────────────────┘
                │                 │
                │ I/O or event   │ interrupt
                │ wait           │
                ▼                │
              ┌───────────────────────────────┐
              │           Waiting             │
              └───────────────────────────────┘
```

### 3.3 CPU 스케줄링

**비선점 (Non-preemptive):**

```
┌─────────────────────────────────────────────────────────────────┐
│  FCFS (First Come First Served)                                 │
│                                                                 │
│  도착: P1(0), P2(1), P3(2)                                      │
│  실행: P1(24) → P2(3) → P3(3)                                   │
│                                                                 │
│  ────[    P1 (24)    ]──[P2]──[P3]──▶                          │
│                                                                 │
│  문제: Convoy Effect (긴 작업이 짧은 작업을 막음)               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  SJF (Shortest Job First)                                       │
│                                                                 │
│  실행 시간: P1(6), P2(8), P3(7), P4(3)                         │
│  순서: P4(3) → P1(6) → P3(7) → P2(8)                           │
│                                                                 │
│  장점: 평균 대기 시간 최소화                                    │
│  단점: 실행 시간 예측 어려움, Starvation                       │
└─────────────────────────────────────────────────────────────────┘
```

**선점 (Preemptive):**

```
┌─────────────────────────────────────────────────────────────────┐
│  Round Robin                                                    │
│                                                                 │
│  Time Quantum = 4                                               │
│  P1(20), P2(10), P3(5)                                         │
│                                                                 │
│  ──[P1]──[P2]──[P3]──[P1]──[P2]──[P3]──[P1]──[P2]──[P1]──...  │
│    4     4     4     4     4     1     4     2     4           │
│                                                                 │
│  장점: 응답 시간 균일, 공정                                     │
│  단점: Context Switch 오버헤드                                  │
│                                                                 │
│  Time Quantum 크면: FCFS에 가까움                               │
│  Time Quantum 작으면: Context Switch 많음                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Priority Scheduling                                            │
│                                                                 │
│  우선순위: P1(3), P2(1), P3(4), P4(2)  (숫자 작을수록 높음)    │
│  순서: P2 → P4 → P1 → P3                                       │
│                                                                 │
│  문제: Starvation (낮은 우선순위 무한 대기)                    │
│  해결: Aging (대기 시간에 따라 우선순위 증가)                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Multi-Level Feedback Queue (MLFQ)                              │
│                                                                 │
│  Queue 0 (높은 우선순위, 짧은 time quantum)                    │
│  ├── 새 프로세스 진입                                           │
│  ├── CPU 많이 쓰면 → Queue 1로 강등                            │
│                                                                 │
│  Queue 1 (중간 우선순위)                                        │
│  ├── CPU 많이 쓰면 → Queue 2로 강등                            │
│                                                                 │
│  Queue 2 (낮은 우선순위, 긴 time quantum)                      │
│  └── CPU bound 프로세스                                         │
│                                                                 │
│  I/O bound: 높은 큐에 유지 (응답성)                             │
│  CPU bound: 낮은 큐로 이동 (처리량)                             │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 Context Switch

```
┌─────────────────────────────────────────────────────────────────┐
│  Context Switch 과정                                            │
│                                                                 │
│  Process A 실행 중                                              │
│       │                                                         │
│       ▼                                                         │
│  인터럽트 또는 시스템 콜                                         │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  1. Process A 상태 저장 (PCB에)                             ││
│  │     - Program Counter                                       ││
│  │     - Stack Pointer                                         ││
│  │     - General Registers                                     ││
│  │     - 메모리 관리 정보                                      ││
│  │     - I/O 상태                                              ││
│  └─────────────────────────────────────────────────────────────┘│
│       │                                                         │
│       ▼                                                         │
│  스케줄러: 다음 실행할 Process B 선택                           │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  2. Process B 상태 복원 (PCB에서)                           ││
│  │     - 레지스터 복원                                         ││
│  │     - 메모리 매핑 변경 (페이지 테이블)                      ││
│  │     - TLB 플러시 (프로세스 간 전환 시)                      ││
│  └─────────────────────────────────────────────────────────────┘│
│       │                                                         │
│       ▼                                                         │
│  Process B 실행                                                 │
│                                                                 │
│  비용: 수 마이크로초 ~ 수십 마이크로초                          │
│  (캐시 미스, TLB 미스로 인한 추가 비용)                        │
└─────────────────────────────────────────────────────────────────┘
```

### 3.5 동기화 기법

**Race Condition:**

```
┌─────────────────────────────────────────────────────────────────┐
│  공유 변수: counter = 0                                         │
│                                                                 │
│  Thread 1              Thread 2                                 │
│  ──────────            ──────────                               │
│  load counter (0)      load counter (0)                        │
│  add 1 (1)             add 1 (1)                               │
│  store counter (1)     store counter (1)                       │
│                                                                 │
│  결과: counter = 1 (기대값: 2)                                  │
│                                                                 │
│  해결: 원자적 연산 또는 동기화 필요                             │
└─────────────────────────────────────────────────────────────────┘
```

**Mutex (Mutual Exclusion):**

```
┌─────────────────────────────────────────────────────────────────┐
│  Critical Section 보호                                          │
│                                                                 │
│  Thread 1              Thread 2                                 │
│  ──────────            ──────────                               │
│  mutex.lock()          mutex.lock() ← 블로킹                   │
│  counter++             (대기...)                                │
│  mutex.unlock()        (획득)                                   │
│                        counter++                                │
│                        mutex.unlock()                           │
│                                                                 │
│  특징:                                                           │
│  - 한 스레드만 진입 가능                                        │
│  - 소유권 개념 (lock한 스레드만 unlock 가능)                   │
└─────────────────────────────────────────────────────────────────┘
```

**Semaphore:**

```
┌─────────────────────────────────────────────────────────────────┐
│  Counting Semaphore (리소스 개수 제한)                          │
│                                                                 │
│  semaphore = 3 (DB 커넥션 풀)                                  │
│                                                                 │
│  Thread 1: wait() → sem=2, 진입                                │
│  Thread 2: wait() → sem=1, 진입                                │
│  Thread 3: wait() → sem=0, 진입                                │
│  Thread 4: wait() → 블로킹 (sem=0)                             │
│                                                                 │
│  Thread 1: signal() → sem=1                                    │
│  Thread 4: (깨어남) → sem=0, 진입                              │
│                                                                 │
│  Mutex vs Semaphore:                                            │
│  - Mutex: 이진 (0 또는 1), 소유권 있음                         │
│  - Semaphore: 카운팅, 소유권 없음 (다른 스레드가 signal 가능)  │
└─────────────────────────────────────────────────────────────────┘
```

**Deadlock:**

```
┌─────────────────────────────────────────────────────────────────┐
│  Deadlock 발생 조건 (모두 만족해야 함)                          │
│                                                                 │
│  1. Mutual Exclusion: 자원 배타적 사용                         │
│  2. Hold and Wait: 자원 보유하며 다른 자원 대기                │
│  3. No Preemption: 자원 강제 회수 불가                         │
│  4. Circular Wait: 순환 대기                                   │
│                                                                 │
│  예시:                                                           │
│  Thread 1: lock(A) → lock(B) 시도 (대기)                       │
│  Thread 2: lock(B) → lock(A) 시도 (대기)                       │
│                                                                 │
│  해결:                                                           │
│  - Prevention: 조건 중 하나 제거 (락 순서 고정 등)             │
│  - Avoidance: Banker's Algorithm                               │
│  - Detection: 주기적으로 감지 후 회복                          │
└─────────────────────────────────────────────────────────────────┘
```

### 3.6 메모리 관리

**가상 메모리:**

```
┌─────────────────────────────────────────────────────────────────┐
│  가상 주소 공간 (Process View)                                  │
│                                                                 │
│  0x00000000 ┌──────────────────────────────────────────────────┐│
│             │  Reserved                                         ││
│  0x00400000 ├──────────────────────────────────────────────────┤│
│             │  Text (Code)                                      ││
│             ├──────────────────────────────────────────────────┤│
│             │  Data (Initialized)                               ││
│             ├──────────────────────────────────────────────────┤│
│             │  BSS (Uninitialized)                              ││
│             ├──────────────────────────────────────────────────┤│
│             │  Heap ↓                                           ││
│             │                                                   ││
│             │        (Free)                                     ││
│             │                                                   ││
│             │  Stack ↑                                          ││
│             ├──────────────────────────────────────────────────┤│
│             │  Kernel Space                                     ││
│  0xFFFFFFFF └──────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

**페이징:**

```
┌─────────────────────────────────────────────────────────────────┐
│  가상 주소 → 물리 주소 변환                                     │
│                                                                 │
│  가상 주소: [   VPN   |   Offset   ]                           │
│              페이지 번호  페이지 내 위치                         │
│                                                                 │
│  Page Table:                                                    │
│  ┌───────┬─────────┬───────┐                                   │
│  │  VPN  │   PFN   │ Flags │                                   │
│  ├───────┼─────────┼───────┤                                   │
│  │   0   │   5     │  RW   │                                   │
│  │   1   │   -     │ Invalid│  ← Page Fault 발생               │
│  │   2   │   10    │  R    │                                   │
│  └───────┴─────────┴───────┘                                   │
│                                                                 │
│  물리 주소: [   PFN   |   Offset   ]                           │
└─────────────────────────────────────────────────────────────────┘
```

**Page Fault:**

```
1. 가상 주소 접근
2. TLB 미스 → Page Table 조회
3. Page Table Entry가 Invalid (메모리에 없음)
4. Page Fault 인터럽트 발생
5. OS가 디스크에서 페이지 로드
6. Page Table 업데이트
7. 프로세스 재개

비용: ~10ms (디스크 접근) vs ~100ns (메모리) = 100,000배
```

**페이지 교체 알고리즘:**

```
┌─────────────────────────────────────────────────────────────────┐
│  FIFO (First In First Out)                                      │
│  - 가장 오래된 페이지 교체                                      │
│  - 구현 간단                                                    │
│  - Belady's Anomaly (프레임 늘려도 fault 증가 가능)            │
│                                                                 │
│  LRU (Least Recently Used)                                      │
│  - 가장 오래 사용 안 한 페이지 교체                            │
│  - 성능 좋음                                                    │
│  - 구현 복잡 (시간 기록 필요)                                  │
│                                                                 │
│  Clock (Second Chance)                                          │
│  - LRU 근사                                                     │
│  - Reference bit 사용                                           │
│  - 원형 큐로 순회                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 3.7 파일 시스템

```
┌─────────────────────────────────────────────────────────────────┐
│  파일 시스템 구조                                                │
│                                                                 │
│  디스크:                                                         │
│  ┌─────┬─────┬─────────────┬─────────────────────────────────┐ │
│  │Boot │Super│   Inode     │          Data Blocks            │ │
│  │Block│Block│   Table     │                                 │ │
│  └─────┴─────┴─────────────┴─────────────────────────────────┘ │
│                                                                 │
│  Inode:                                                         │
│  - 파일 메타데이터 (크기, 권한, 시간, 소유자)                  │
│  - 데이터 블록 포인터                                           │
│                                                                 │
│  디렉토리:                                                       │
│  - 파일명 → Inode 번호 매핑                                    │
└─────────────────────────────────────────────────────────────────┘
```

**I/O 버퍼링:**

```
┌─────────────────────────────────────────────────────────────────┐
│  Application                                                    │
│       │ write()                                                 │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  User Buffer (애플리케이션 메모리)                          ││
│  └─────────────────────────────────────────────────────────────┘│
│       │ 시스템 콜                                               │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  Kernel Buffer (Page Cache)                                 ││
│  │  - write() 반환 (아직 디스크 안 씀)                         ││
│  │  - 주기적으로 또는 fsync() 시 디스크에 씀                   ││
│  └─────────────────────────────────────────────────────────────┘│
│       │ 디스크 I/O                                             │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  Disk                                                       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  Durability:                                                    │
│  - write(): 커널 버퍼까지만 보장                               │
│  - fsync(): 디스크까지 보장                                    │
│  - O_DIRECT: 커널 버퍼 우회                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 3.8 Node.js와 운영체제

**싱글 스레드 + Non-blocking I/O:**

```
┌─────────────────────────────────────────────────────────────────┐
│  전통적 멀티스레드 서버                                          │
│                                                                 │
│  요청 1 → Thread 1 → I/O 대기 (Block) → 응답                   │
│  요청 2 → Thread 2 → I/O 대기 (Block) → 응답                   │
│  ...                                                            │
│  요청 N → Thread N                                              │
│                                                                 │
│  문제:                                                           │
│  - 스레드 생성 비용                                             │
│  - 메모리 (스레드당 ~1MB 스택)                                 │
│  - Context Switch 비용                                          │
│  - 동기화 복잡성                                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Node.js (Single Thread + Event Loop)                           │
│                                                                 │
│  Main Thread:                                                   │
│  요청 1 → I/O 요청 → 요청 2 → I/O 요청 → ...                   │
│                │           │                                    │
│                └───────────┴───▶ 콜백 큐                       │
│                                                                 │
│  I/O 완료:                                                      │
│  콜백 1 → 콜백 2 → ... (순차 실행)                              │
│                                                                 │
│  장점:                                                           │
│  - Context Switch 최소                                          │
│  - 메모리 효율                                                  │
│  - 동기화 불필요 (싱글 스레드)                                  │
│                                                                 │
│  주의:                                                           │
│  - CPU 집약적 작업 → Worker Thread                              │
│  - 동기 API 피하기                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 3.9 면접 포인트: 운영체제

| 질문                  | 핵심 답변                                                          |
| --------------------- | ------------------------------------------------------------------ |
| 프로세스 vs 스레드?   | 프로세스: 독립 메모리. 스레드: Code/Data/Heap 공유, Stack 독립     |
| Context Switch 비용?  | 레지스터 저장/복원, TLB 플러시, 캐시 콜드                          |
| Deadlock 조건?        | 상호배제 + 점유대기 + 비선점 + 순환대기 (모두 필요)                |
| 페이지 교체 알고리즘? | FIFO (간단), LRU (성능 좋음), Clock (LRU 근사)                     |
| Node.js 왜 빠른가?    | 싱글 스레드 + Non-blocking I/O + Event Loop → Context Switch 최소 |

---

## 4. 데이터베이스

### 4.1 ACID

```
┌─────────────────────────────────────────────────────────────────┐
│  Atomicity (원자성)                                              │
│  - 트랜잭션의 모든 연산이 성공하거나 모두 실패                   │
│  - 구현: Undo Log (롤백용)                                      │
│                                                                 │
│  Consistency (일관성)                                            │
│  - 트랜잭션 전후로 DB 무결성 제약조건 만족                      │
│  - 구현: 제약조건 검사, 트리거                                   │
│                                                                 │
│  Isolation (격리성)                                              │
│  - 동시 실행 트랜잭션이 서로 간섭하지 않음                      │
│  - 구현: 락, MVCC                                               │
│                                                                 │
│  Durability (지속성)                                             │
│  - 커밋된 트랜잭션은 영구적으로 저장                            │
│  - 구현: WAL (Write-Ahead Logging), fsync                       │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 트랜잭션 격리 수준

```
┌─────────────────────────────────────────────────────────────────┐
│  격리 수준별 문제 발생 가능성                                    │
│                                                                 │
│  Level              │ Dirty  │ Non-Rep │ Phantom │ 성능        │
│  ──────────────────┼────────┼─────────┼─────────┼─────────────│
│  READ UNCOMMITTED  │   O    │    O    │    O    │ 가장 빠름   │
│  READ COMMITTED    │   X    │    O    │    O    │ 빠름        │
│  REPEATABLE READ   │   X    │    X    │    O    │ 보통        │
│  SERIALIZABLE      │   X    │    X    │    X    │ 가장 느림   │
└─────────────────────────────────────────────────────────────────┘

Dirty Read: 커밋 안 된 데이터 읽기
Non-Repeatable Read: 같은 쿼리가 다른 결과
Phantom Read: 같은 조건인데 행이 추가/삭제됨
```

**각 문제 상황:**

```sql
-- Dirty Read
-- Tx1                          Tx2
UPDATE users SET balance=100;
                                SELECT balance; -- 100 (커밋 안 됨!)
ROLLBACK;
                                -- 이미 100으로 계산함 → 틀린 값 사용

-- Non-Repeatable Read
-- Tx1                          Tx2
SELECT balance; -- 1000
                                UPDATE users SET balance=500;
                                COMMIT;
SELECT balance; -- 500 (다름!)

-- Phantom Read
-- Tx1                          Tx2
SELECT COUNT(*) WHERE age>20; -- 5
                                INSERT INTO users (age) VALUES (25);
                                COMMIT;
SELECT COUNT(*) WHERE age>20; -- 6 (유령 행!)
```

### 4.3 락 (Lock)

```
┌─────────────────────────────────────────────────────────────────┐
│  공유 락 (S Lock, Shared Lock)                                  │
│  - 읽기용                                                        │
│  - 여러 트랜잭션이 동시에 획득 가능                              │
│  - SELECT ... FOR SHARE                                         │
│                                                                 │
│  배타 락 (X Lock, Exclusive Lock)                               │
│  - 쓰기용                                                        │
│  - 하나의 트랜잭션만 획득 가능                                   │
│  - SELECT ... FOR UPDATE                                        │
│                                                                 │
│  호환성:                                                         │
│       │ S Lock │ X Lock │                                       │
│  ─────┼────────┼────────│                                       │
│  S Lock│   O    │   X    │                                       │
│  X Lock│   X    │   X    │                                       │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 낙관적 락 vs 비관적 락

```typescript
// 비관적 락 (Pessimistic Locking)
// 충돌이 자주 발생할 것으로 예상
async function pessimisticTransfer(fromId: number, toId: number, amount: number) {
  await db.query('BEGIN');
  try {
    // 락 먼저 획득
    const [from] = await db.query(
      'SELECT * FROM accounts WHERE id = ? FOR UPDATE',
      [fromId]
    );
    const [to] = await db.query(
      'SELECT * FROM accounts WHERE id = ? FOR UPDATE',
      [toId]
    );

    await db.query('UPDATE accounts SET balance = balance - ? WHERE id = ?', [amount, fromId]);
    await db.query('UPDATE accounts SET balance = balance + ? WHERE id = ?', [amount, toId]);

    await db.query('COMMIT');
  } catch (e) {
    await db.query('ROLLBACK');
    throw e;
  }
}

// 낙관적 락 (Optimistic Locking)
// 충돌이 드물 것으로 예상
async function optimisticUpdate(userId: number, newName: string) {
  const [user] = await db.query(
    'SELECT * FROM users WHERE id = ?',
    [userId]
  );

  const result = await db.query(
    'UPDATE users SET name = ?, version = version + 1 WHERE id = ? AND version = ?',
    [newName, userId, user.version]  // 버전 체크
  );

  if (result.affectedRows === 0) {
    throw new Error('Conflict: 다른 트랜잭션이 먼저 수정함');
  }
}
```

**선택 기준:**

| 상황           | 권장                            |
| -------------- | ------------------------------- |
| 충돌 빈도 높음 | 비관적 락                       |
| 충돌 빈도 낮음 | 낙관적 락                       |
| 긴 트랜잭션    | 낙관적 락 (락 점유 시간 최소화) |
| 짧은 트랜잭션  | 비관적 락 가능                  |

### 4.5 MVCC (Multi-Version Concurrency Control)

```
┌─────────────────────────────────────────────────────────────────┐
│  MVCC 동작 (PostgreSQL/MySQL InnoDB)                           │
│                                                                 │
│  각 행에 버전 정보 저장:                                         │
│  - xmin: 이 버전을 생성한 트랜잭션 ID                          │
│  - xmax: 이 버전을 삭제/수정한 트랜잭션 ID                     │
│                                                                 │
│  users 테이블:                                                   │
│  ┌────┬─────────┬──────┬──────┐                                │
│  │ id │  name   │ xmin │ xmax │                                │
│  ├────┼─────────┼──────┼──────┤                                │
│  │ 1  │ 'kim'   │  10  │  20  │  ← Tx20에서 수정됨            │
│  │ 1  │ 'park'  │  20  │  ∞   │  ← Tx20이 생성한 새 버전      │
│  │ 2  │ 'lee'   │  15  │  ∞   │                                │
│  └────┴─────────┴──────┴──────┘                                │
│                                                                 │
│  Tx25가 읽을 때:                                                │
│  - xmin <= 25 이고 (커밋됨)                                    │
│  - xmax > 25 (아직 유효) 인 행만 보임                          │
│  - id=1 → 'park' 보임                                          │
│                                                                 │
│  장점: 읽기/쓰기 충돌 없음 (락 없이 일관된 읽기)               │
│  단점: 저장 공간 증가, Vacuum 필요                              │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 인덱스

**B+Tree 구조:**

```
┌─────────────────────────────────────────────────────────────────┐
│  B+Tree Index                                                   │
│                                                                 │
│                        [30 | 60]              ← 루트 노드       │
│                       /    |    \                               │
│              [10|20]    [40|50]    [70|80|90]  ← 내부 노드      │
│              /  |  \    /  |  \    /  |  |  \                   │
│           [D][D][D]  [D][D][D]  [D][D][D][D]   ← 리프 노드      │
│            ↓  ↓  ↓    ↓  ↓  ↓    ↓  ↓  ↓  ↓                    │
│           실제 데이터 또는 PK 포인터                             │
│                                                                 │
│  특징:                                                           │
│  - 모든 데이터는 리프 노드에                                    │
│  - 리프 노드끼리 연결 (범위 검색 효율)                          │
│  - 항상 균형 (모든 리프가 같은 깊이)                            │
│  - 시간 복잡도: O(log n)                                        │
│                                                                 │
│  디스크 친화적:                                                  │
│  - 노드 크기 = 디스크 블록 크기 (4KB~16KB)                     │
│  - 한 번의 I/O로 여러 키 접근                                  │
└─────────────────────────────────────────────────────────────────┘
```

**클러스터 인덱스 vs 보조 인덱스:**

```
┌─────────────────────────────────────────────────────────────────┐
│  클러스터 인덱스 (Clustered Index)                               │
│  - 테이블당 하나 (보통 PK)                                      │
│  - 리프 노드 = 실제 데이터 행                                   │
│  - 데이터가 인덱스 키 순서로 물리적 정렬                        │
│                                                                 │
│  보조 인덱스 (Secondary Index)                                   │
│  - 여러 개 가능                                                  │
│  - 리프 노드 = PK 값 저장                                       │
│  - 조회 시 PK로 클러스터 인덱스 다시 조회 (double lookup)      │
│                                                                 │
│  Covering Index:                                                │
│  - 쿼리에 필요한 모든 컬럼이 인덱스에 포함                     │
│  - 테이블 접근 없이 인덱스만으로 결과 반환                      │
│  - CREATE INDEX idx ON users(status, name) ← name 포함         │
│  - SELECT name FROM users WHERE status = 'active' ← 테이블 안 봄│
└─────────────────────────────────────────────────────────────────┘
```

**복합 인덱스:**

```sql
-- 인덱스 생성
CREATE INDEX idx_status_age_created ON users(status, age, created_at);

-- ✅ 인덱스 사용 (왼쪽부터 순서대로)
WHERE status = 'active'
WHERE status = 'active' AND age > 20
WHERE status = 'active' AND age = 25 ORDER BY created_at

-- ❌ 인덱스 미사용 또는 비효율
WHERE age > 20                        -- status 없음
WHERE status = 'active' ORDER BY created_at  -- age 건너뜀
WHERE age = 25 AND status = 'active'  -- 순서 바뀜 (옵티마이저가 조정할 수도 있음)
```

### 4.7 실행 계획 분석

```sql
EXPLAIN ANALYZE
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.status = 'active'
AND o.created_at > '2024-01-01'
ORDER BY o.created_at DESC
LIMIT 100;

-- 주요 지표:
-- type: ALL(풀스캔), index, range, ref, eq_ref, const
-- key: 사용된 인덱스
-- rows: 예상 검사 행 수
-- Extra: Using where, Using index, Using filesort, Using temporary

-- 문제 패턴:
-- type: ALL → 인덱스 추가 필요
-- Using filesort → ORDER BY 인덱스 활용 불가
-- Using temporary → GROUP BY/DISTINCT 최적화 필요
```

### 4.8 정규화 vs 반정규화

```
┌─────────────────────────────────────────────────────────────────┐
│  정규화 (Normalization)                                         │
│                                                                 │
│  목적: 데이터 중복 제거, 무결성 보장                            │
│                                                                 │
│  1NF: 원자값 (하나의 셀에 하나의 값)                           │
│  2NF: 부분 함수 종속 제거 (PK 전체에 종속)                     │
│  3NF: 이행 함수 종속 제거 (A→B, B→C면 A→C 분리)               │
│  BCNF: 모든 결정자가 후보키                                     │
│                                                                 │
│  장점: 데이터 일관성, 저장 공간 효율                            │
│  단점: JOIN 증가 → 성능 저하                                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  반정규화 (Denormalization)                                     │
│                                                                 │
│  목적: 읽기 성능 향상                                           │
│                                                                 │
│  기법:                                                           │
│  - 테이블 병합 (JOIN 제거)                                     │
│  - 컬럼 중복 (자주 조회하는 값)                                 │
│  - 파생 컬럼 추가 (계산된 값 저장)                              │
│  - 요약 테이블 (집계 결과 저장)                                 │
│                                                                 │
│  주의: 데이터 동기화 복잡성 증가                                │
│                                                                 │
│  예시:                                                           │
│  orders 테이블에 user_name 컬럼 추가                            │
│  → users JOIN 없이 주문 목록 조회 가능                         │
│  → 단, 사용자 이름 변경 시 orders도 업데이트 필요              │
└─────────────────────────────────────────────────────────────────┘
```

### 4.9 파티셔닝

```
┌─────────────────────────────────────────────────────────────────┐
│  수평 파티셔닝 (Horizontal Partitioning)                        │
│                                                                 │
│  orders 테이블을 날짜별로 분할:                                  │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐    │
│  │ orders_2023_q1 │  │ orders_2023_q2 │  │ orders_2023_q3 │    │
│  │ (1~3월 데이터) │  │ (4~6월 데이터) │  │ (7~9월 데이터) │    │
│  └────────────────┘  └────────────────┘  └────────────────┘    │
│                                                                 │
│  장점:                                                           │
│  - 파티션 프루닝 (해당 파티션만 검색)                          │
│  - 파티션별 관리 (백업, 삭제, 인덱스)                          │
│  - 병렬 처리 가능                                               │
│                                                                 │
│  종류:                                                           │
│  - Range: 날짜, 숫자 범위                                       │
│  - List: 특정 값 목록 (지역, 카테고리)                         │
│  - Hash: 해시 함수 결과                                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  수직 파티셔닝 (Vertical Partitioning)                          │
│                                                                 │
│  users 테이블을 컬럼별로 분할:                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ users_core  │  │ users_profile│ │ users_prefs │             │
│  │ id, email   │  │ id, bio     │  │ id, settings│             │
│  │ password    │  │ avatar      │  │ theme       │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                 │
│  용도:                                                           │
│  - 자주 접근하는 컬럼 분리                                      │
│  - 큰 컬럼 분리 (BLOB, TEXT)                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 4.10 커넥션 풀

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  host: 'localhost',
  database: 'mydb',
  max: 20,                    // 최대 커넥션 수
  idleTimeoutMillis: 30000,   // 유휴 커넥션 타임아웃
  connectionTimeoutMillis: 2000  // 커넥션 획득 대기 타임아웃
});

// 자동 커넥션 관리
async function query(sql: string, params: any[]) {
  return pool.query(sql, params);
  // 커넥션 자동 반환
}

// 트랜잭션 (같은 커넥션 유지)
async function transfer(from: number, to: number, amount: number) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, from]);
    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, to]);
    await client.query('COMMIT');
  } catch (e) {
    await client.query('ROLLBACK');
    throw e;
  } finally {
    client.release();  // 반드시 반환!
  }
}
```

### 4.11 면접 포인트: 데이터베이스

| 질문                 | 핵심 답변                                                                          |
| -------------------- | ---------------------------------------------------------------------------------- |
| ACID 설명?           | Atomicity(전부/전무), Consistency(제약조건), Isolation(격리), Durability(영구저장) |
| 격리 수준별 차이?    | READ UNCOMMITTED~SERIALIZABLE. 높을수록 안전하지만 느림                            |
| 낙관적 vs 비관적 락? | 낙관적: 버전 체크, 충돌 적을 때. 비관적: 미리 락, 충돌 많을 때                     |
| 인덱스 동작 원리?    | B+Tree: 리프에 데이터, 정렬 유지, O(log n)                                         |
| 복합 인덱스 순서?    | 왼쪽부터 사용, 중간 건너뛰면 이후 미사용                                           |
| 정규화 vs 반정규화?  | 정규화: 중복 제거, JOIN 증가. 반정규화: 읽기 최적화, 동기화 복잡                   |

---

## 5. Node.js 런타임 심화

> 상세 내용은 기존 문서 참조:
>
> - [V8 엔진의 Async/Await 처리 분석](../javascript/async_await.md)
> - [Node.js 스레드 심화](../node.js/thread_deep_dive.md)
> - [Node.js HTTP 요청 처리 내부 동작](../node.js/http_internals.md)
> - [Node.js AsyncLocalStorage 분석](../node.js/async_local_storage.md)

### 5.1 Event Loop

```
   ┌───────────────────────────┐
┌─▶│           timers          │  setTimeout, setInterval
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │     pending callbacks     │  시스템 콜백 (TCP 에러 등)
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │       idle, prepare       │  내부 용도
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────▼─────────────┐      │   incoming:   │
│  │           poll            │◀─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────▼─────────────┐      └───────────────┘
│  │           check           │  setImmediate
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
└──┤      close callbacks      │  socket.on('close')
   └───────────────────────────┘

각 단계 사이: Microtask Queue 처리
- process.nextTick (가장 먼저)
- Promise.then
```

### 5.2 실행 순서 예제

```javascript
console.log('1: sync');

setTimeout(() => console.log('2: setTimeout'), 0);

setImmediate(() => console.log('3: setImmediate'));

Promise.resolve().then(() => console.log('4: Promise'));

process.nextTick(() => console.log('5: nextTick'));

console.log('6: sync end');

// 출력:
// 1: sync
// 6: sync end
// 5: nextTick      ← Microtask (nextTick 우선)
// 4: Promise       ← Microtask
// 2: setTimeout    ← Timer phase
// 3: setImmediate  ← Check phase
```

### 5.3 libuv Thread Pool

```javascript
// Thread Pool 사용 API (기본 4개, UV_THREADPOOL_SIZE로 조절)
const crypto = require('crypto');
const fs = require('fs');

// Thread Pool 사용:
// - fs 비동기 API (readFile, writeFile 등)
// - crypto (pbkdf2, randomBytes)
// - dns.lookup
// - zlib

// 동시 실행 테스트
const start = Date.now();
for (let i = 0; i < 8; i++) {
  crypto.pbkdf2('password', 'salt', 100000, 64, 'sha512', () => {
    console.log(`${i}: ${Date.now() - start}ms`);
  });
}
// 0-3: ~70ms (동시 실행)
// 4-7: ~140ms (대기 후 실행)
```

### 5.4 Worker Threads vs Cluster

```javascript
// Worker Threads: CPU 집약적 작업
import { Worker, isMainThread, workerData, parentPort } from 'worker_threads';

if (isMainThread) {
  const worker = new Worker(__filename, {
    workerData: { num: 1000000000 }
  });
  worker.on('message', result => console.log(result));
} else {
  let sum = 0;
  for (let i = 0; i < workerData.num; i++) sum += i;
  parentPort.postMessage(sum);
}

// Cluster: HTTP 서버 스케일링
import cluster from 'cluster';
import http from 'http';
import os from 'os';

if (cluster.isPrimary) {
  for (let i = 0; i < os.cpus().length; i++) {
    cluster.fork();
  }
} else {
  http.createServer((req, res) => {
    res.end('Hello from ' + process.pid);
  }).listen(3000);
}
```

### 5.5 Streams과 Backpressure

```javascript
import { createReadStream, createWriteStream } from 'fs';

const readable = createReadStream('huge-file.txt');
const writable = createWriteStream('output.txt');

// pipe가 자동으로 backpressure 처리
readable.pipe(writable);

// 수동 처리
readable.on('data', (chunk) => {
  const canWrite = writable.write(chunk);
  if (!canWrite) {
    readable.pause();  // 버퍼 가득 참
  }
});

writable.on('drain', () => {
  readable.resume();  // 버퍼 비워짐
});
```

### 5.6 V8 Garbage Collection

```
┌─────────────────────────────────────────────────────────────────┐
│  V8 Heap 구조                                                    │
│                                                                 │
│  Young Generation (New Space)                                   │
│  ├─ Semi-space 1 (From)                                        │
│  └─ Semi-space 2 (To)                                          │
│  - 새로 생성된 객체                                             │
│  - Scavenge GC (빠름, 자주)                                    │
│                                                                 │
│  Old Generation (Old Space)                                     │
│  - 오래 살아남은 객체                                           │
│  - Mark-Sweep-Compact GC (느림, 드물게)                        │
│                                                                 │
│  메모리 제한 (64bit 기준):                                       │
│  - New Space: ~32MB                                             │
│  - Old Space: ~1.4GB                                            │
│  - --max-old-space-size로 조절                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 면접 포인트: Node.js

| 질문                      | 핵심 답변                                                           |
| ------------------------- | ------------------------------------------------------------------- |
| Event Loop 단계?          | timers → pending → poll → check → close. 각 단계 사이 microtask |
| nextTick vs setImmediate? | nextTick: microtask (즉시). setImmediate: check phase (다음 루프)   |
| libuv Thread Pool?        | 기본 4개. fs, crypto, dns.lookup 사용. UV_THREADPOOL_SIZE로 조절    |
| Worker vs Cluster?        | Worker: 스레드 (메모리 공유). Cluster: 프로세스 (독립)              |
| Backpressure?             | 생산 > 소비 시 일시 중지. write() 반환값, drain 이벤트              |

---

## 종합 면접 시나리오

### Q: "10,000개의 동시 연결을 처리할 수 있는 이유는?"

```
1. 싱글스레드 + Non-blocking I/O
   - I/O 대기 중 다른 요청 처리 가능
   - Context Switch 비용 최소화

2. epoll/kqueue (I/O 멀티플렉싱)
   - O(1) 이벤트 감지
   - 활성 연결만 처리

3. Event Loop
   - 콜백 기반 비동기 처리
   - Microtask 우선 처리

4. 주의사항
   - CPU 집약적 작업은 블로킹 → Worker Thread 사용
   - 동기 API 피하기 (fs.readFileSync 등)
```

### Q: "트랜잭션 격리 수준을 어떻게 선택하나요?"

```
1. 대부분의 경우: READ COMMITTED (PostgreSQL 기본값)
   - Dirty Read 방지
   - 적절한 성능

2. 금융/결제: REPEATABLE READ 또는 SERIALIZABLE
   - 데이터 정합성 중요
   - 성능 트레이드오프 감수

3. 읽기 전용 리포트: READ UNCOMMITTED
   - 정확도보다 성능 우선
   - 대략적인 통계 조회

4. 실제로는:
   - 낙관적 락 + READ COMMITTED 조합
   - 필요한 곳만 FOR UPDATE
```

---

## 참고 자료

- TCP/IP Illustrated, Volume 1 - W. Richard Stevens
- Operating System Concepts - Silberschatz
- Database System Concepts - Silberschatz
- Node.js Documentation: https://nodejs.org/docs
- V8 Documentation: https://v8.dev/docs
